#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Jan 25 01:07:59 2011 by generateDS.py version 2.3b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_str_lower(self, instring):
            return instring.lower()
                    
                    

#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class MSALead(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Version='1.0', LeadData=None):
        self.Version = _cast(None, Version)
        self.LeadData = LeadData
    def factory(*args_, **kwargs_):
        if MSALead.subclass:
            return MSALead.subclass(*args_, **kwargs_)
        else:
            return MSALead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LeadData(self): return self.LeadData
    def set_LeadData(self, LeadData): self.LeadData = LeadData
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def export(self, outfile, level, namespace_='', name_='MSALead', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='MSALead')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MSALead'):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.append('Version')
            outfile.write(' Version=%s' % (self.gds_format_string(quote_attrib(self.Version).encode(ExternalEncoding), input_name='Version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MSALead'):
        if self.LeadData:
            self.LeadData.export(outfile, level, namespace_, name_='LeadData', )
    def hasContent_(self):
        if (
            self.LeadData is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MSALead'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Version is not None and 'Version' not in already_processed:
            already_processed.append('Version')
            showIndent(outfile, level)
            outfile.write('Version = "%s",\n' % (self.Version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LeadData is not None:
            showIndent(outfile, level)
            outfile.write('LeadData=model_.LeadData(\n')
            self.LeadData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Version')
        if value is not None and 'Version' not in already_processed:
            already_processed.append('Version')
            self.Version = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'LeadData': 
            obj_ = LeadData.factory()
            obj_.build(child_)
            self.set_LeadData(obj_)
# end class MSALead


class LeadData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartnerExcludeDirective=None, ContactDetails=None, InsurancePolicy=None, AutoLead=None, HomeLead=None):
        self.PartnerExcludeDirective = PartnerExcludeDirective
        self.ContactDetails = ContactDetails
        self.InsurancePolicy = InsurancePolicy
        self.AutoLead = AutoLead
        self.HomeLead = HomeLead
    def factory(*args_, **kwargs_):
        if LeadData.subclass:
            return LeadData.subclass(*args_, **kwargs_)
        else:
            return LeadData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerExcludeDirective(self): return self.PartnerExcludeDirective
    def set_PartnerExcludeDirective(self, PartnerExcludeDirective): self.PartnerExcludeDirective = PartnerExcludeDirective
    def get_ContactDetails(self): return self.ContactDetails
    def set_ContactDetails(self, ContactDetails): self.ContactDetails = ContactDetails
    def get_InsurancePolicy(self): return self.InsurancePolicy
    def set_InsurancePolicy(self, InsurancePolicy): self.InsurancePolicy = InsurancePolicy
    def get_AutoLead(self): return self.AutoLead
    def set_AutoLead(self, AutoLead): self.AutoLead = AutoLead
    def get_HomeLead(self): return self.HomeLead
    def set_HomeLead(self, HomeLead): self.HomeLead = HomeLead
    def export(self, outfile, level, namespace_='', name_='LeadData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='LeadData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LeadData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LeadData'):
        if self.PartnerExcludeDirective:
            self.PartnerExcludeDirective.export(outfile, level, namespace_, name_='PartnerExcludeDirective')
        if self.ContactDetails:
            self.ContactDetails.export(outfile, level, namespace_, name_='ContactDetails', )
        if self.InsurancePolicy:
            self.InsurancePolicy.export(outfile, level, namespace_, name_='InsurancePolicy', )
        if self.AutoLead:
            self.AutoLead.export(outfile, level, namespace_, name_='AutoLead', )
        if self.HomeLead:
            self.HomeLead.export(outfile, level, namespace_, name_='HomeLead', )
    def hasContent_(self):
        if (
            self.PartnerExcludeDirective is not None or
            self.ContactDetails is not None or
            self.InsurancePolicy is not None or
            self.AutoLead is not None or
            self.HomeLead is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LeadData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PartnerExcludeDirective is not None:
            showIndent(outfile, level)
            outfile.write('PartnerExcludeDirective=model_.PartnerExcludeDirective(\n')
            self.PartnerExcludeDirective.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ContactDetails is not None:
            showIndent(outfile, level)
            outfile.write('ContactDetails=model_.ContactDetails(\n')
            self.ContactDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InsurancePolicy is not None:
            showIndent(outfile, level)
            outfile.write('InsurancePolicy=model_.InsurancePolicy(\n')
            self.InsurancePolicy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutoLead is not None:
            showIndent(outfile, level)
            outfile.write('AutoLead=model_.AutoLead(\n')
            self.AutoLead.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HomeLead is not None:
            showIndent(outfile, level)
            outfile.write('HomeLead=model_.HomeLead(\n')
            self.HomeLead.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PartnerExcludeDirective': 
            obj_ = PartnerExcludeDirective.factory()
            obj_.build(child_)
            self.set_PartnerExcludeDirective(obj_)
        elif nodeName_ == 'ContactDetails': 
            obj_ = ContactDetails.factory()
            obj_.build(child_)
            self.set_ContactDetails(obj_)
        elif nodeName_ == 'InsurancePolicy': 
            obj_ = InsurancePolicy.factory()
            obj_.build(child_)
            self.set_InsurancePolicy(obj_)
        elif nodeName_ == 'AutoLead': 
            obj_ = AutoLead.factory()
            obj_.build(child_)
            self.set_AutoLead(obj_)
        elif nodeName_ == 'HomeLead': 
            obj_ = HomeLead.factory()
            obj_.build(child_)
            self.set_HomeLead(obj_)
# end class LeadData


class PartnerExcludeDirectiveType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PartnerExclude=None):
        if PartnerExclude is None:
            self.PartnerExclude = []
        else:
            self.PartnerExclude = PartnerExclude
    def factory(*args_, **kwargs_):
        if PartnerExcludeDirectiveType.subclass:
            return PartnerExcludeDirectiveType.subclass(*args_, **kwargs_)
        else:
            return PartnerExcludeDirectiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PartnerExclude(self): return self.PartnerExclude
    def set_PartnerExclude(self, PartnerExclude): self.PartnerExclude = PartnerExclude
    def add_PartnerExclude(self, value): self.PartnerExclude.append(value)
    def insert_PartnerExclude(self, index, value): self.PartnerExclude[index] = value
    def validate_PartnerExclude(self, value):
        # validate type PartnerExclude
        pass
    def export(self, outfile, level, namespace_='', name_='PartnerExcludeDirectiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PartnerExcludeDirectiveType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartnerExcludeDirectiveType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PartnerExcludeDirectiveType'):
        for PartnerExclude_ in self.PartnerExclude:
            showIndent(outfile, level)
            outfile.write('<%sPartnerExclude>%s</%sPartnerExclude>\n' % (namespace_, self.gds_format_string(quote_xml(PartnerExclude_).encode(ExternalEncoding), input_name='PartnerExclude'), namespace_))
    def hasContent_(self):
        if (
            self.PartnerExclude
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PartnerExcludeDirectiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PartnerExclude=[\n')
        level += 1
        for PartnerExclude_ in self.PartnerExclude:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PartnerExclude_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PartnerExclude':
            PartnerExclude_ = child_.text
            self.PartnerExclude.append(PartnerExclude_)
            self.validate_PartnerExclude(self.PartnerExclude)    # validate type PartnerExclude
# end class PartnerExcludeDirectiveType


class ContactDetailsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FirstName=None, LastName=None, StreetAddress=None, City=None, State=None, ZIPCode=None, Email=None, PhoneNumbers=None, ResidenceStatus=None):
        self.FirstName = FirstName
        self.LastName = LastName
        self.StreetAddress = StreetAddress
        self.City = City
        self.State = State
        self.ZIPCode = ZIPCode
        self.Email = Email
        self.PhoneNumbers = PhoneNumbers
        self.ResidenceStatus = ResidenceStatus
    def factory(*args_, **kwargs_):
        if ContactDetailsType.subclass:
            return ContactDetailsType.subclass(*args_, **kwargs_)
        else:
            return ContactDetailsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_StreetAddress(self): return self.StreetAddress
    def set_StreetAddress(self, StreetAddress): self.StreetAddress = StreetAddress
    def get_City(self): return self.City
    def set_City(self, City): self.City = City
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    def validate_State(self, value):
        # validate type State
        pass
    def get_ZIPCode(self): return self.ZIPCode
    def set_ZIPCode(self, ZIPCode): self.ZIPCode = ZIPCode
    def validate_ZIPCode(self, value):
        # validate type ZIPCode
        pass
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def validate_Email(self, value):
        # validate type Email
        pass
    def get_PhoneNumbers(self): return self.PhoneNumbers
    def set_PhoneNumbers(self, PhoneNumbers): self.PhoneNumbers = PhoneNumbers
    def get_ResidenceStatus(self): return self.ResidenceStatus
    def set_ResidenceStatus(self, ResidenceStatus): self.ResidenceStatus = ResidenceStatus
    def export(self, outfile, level, namespace_='', name_='ContactDetailsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ContactDetailsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactDetailsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ContactDetailsType'):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('<%sFirstName>%s</%sFirstName>\n' % (namespace_, self.gds_format_string(quote_xml(self.FirstName).encode(ExternalEncoding), input_name='FirstName'), namespace_))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastName>%s</%sLastName>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastName).encode(ExternalEncoding), input_name='LastName'), namespace_))
        if self.StreetAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%sStreetAddress>%s</%sStreetAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.StreetAddress).encode(ExternalEncoding), input_name='StreetAddress'), namespace_))
        if self.City is not None:
            showIndent(outfile, level)
            outfile.write('<%sCity>%s</%sCity>\n' % (namespace_, self.gds_format_string(quote_xml(self.City).encode(ExternalEncoding), input_name='City'), namespace_))
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('<%sState>%s</%sState>\n' % (namespace_, self.gds_format_string(quote_xml(self.State).encode(ExternalEncoding), input_name='State'), namespace_))
        if self.ZIPCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sZIPCode>%s</%sZIPCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.ZIPCode).encode(ExternalEncoding), input_name='ZIPCode'), namespace_))
        if self.Email is not None:
            showIndent(outfile, level)
            outfile.write('<%sEmail>%s</%sEmail>\n' % (namespace_, self.gds_format_string(quote_xml(self.Email).encode(ExternalEncoding), input_name='Email'), namespace_))
        if self.PhoneNumbers:
            self.PhoneNumbers.export(outfile, level, namespace_, name_='PhoneNumbers', )
        if self.ResidenceStatus:
            self.ResidenceStatus.export(outfile, level, namespace_, name_='ResidenceStatus', )
    def hasContent_(self):
        if (
            self.FirstName is not None or
            self.LastName is not None or
            self.StreetAddress is not None or
            self.City is not None or
            self.State is not None or
            self.ZIPCode is not None or
            self.Email is not None or
            self.PhoneNumbers is not None or
            self.ResidenceStatus is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactDetailsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('FirstName=%s,\n' % quote_python(self.FirstName).encode(ExternalEncoding))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('LastName=%s,\n' % quote_python(self.LastName).encode(ExternalEncoding))
        if self.StreetAddress is not None:
            showIndent(outfile, level)
            outfile.write('StreetAddress=%s,\n' % quote_python(self.StreetAddress).encode(ExternalEncoding))
        if self.City is not None:
            showIndent(outfile, level)
            outfile.write('City=%s,\n' % quote_python(self.City).encode(ExternalEncoding))
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('State=%s,\n' % quote_python(self.State).encode(ExternalEncoding))
        if self.ZIPCode is not None:
            showIndent(outfile, level)
            outfile.write('ZIPCode=%s,\n' % quote_python(self.ZIPCode).encode(ExternalEncoding))
        if self.Email is not None:
            showIndent(outfile, level)
            outfile.write('Email=%s,\n' % quote_python(self.Email).encode(ExternalEncoding))
        if self.PhoneNumbers is not None:
            showIndent(outfile, level)
            outfile.write('PhoneNumbers=model_.PhoneNumbers(\n')
            self.PhoneNumbers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResidenceStatus is not None:
            showIndent(outfile, level)
            outfile.write('ResidenceStatus=model_.ResidenceStatusType(\n')
            self.ResidenceStatus.exportLiteral(outfile, level, name_='ResidenceStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'FirstName':
            FirstName_ = child_.text
            self.FirstName = FirstName_
        elif nodeName_ == 'LastName':
            LastName_ = child_.text
            self.LastName = LastName_
        elif nodeName_ == 'StreetAddress':
            StreetAddress_ = child_.text
            self.StreetAddress = StreetAddress_
        elif nodeName_ == 'City':
            City_ = child_.text
            self.City = City_
        elif nodeName_ == 'State':
            State_ = child_.text
            self.State = State_
            self.validate_State(self.State)    # validate type State
        elif nodeName_ == 'ZIPCode':
            ZIPCode_ = child_.text
            self.ZIPCode = ZIPCode_
            self.validate_ZIPCode(self.ZIPCode)    # validate type ZIPCode
        elif nodeName_ == 'Email':
            Email_ = child_.text
            self.Email = Email_
            self.validate_Email(self.Email)    # validate type Email
        elif nodeName_ == 'PhoneNumbers': 
            obj_ = PhoneNumbers.factory()
            obj_.build(child_)
            self.set_PhoneNumbers(obj_)
        elif nodeName_ == 'ResidenceStatus': 
            obj_ = ResidenceStatusType.factory()
            obj_.build(child_)
            self.set_ResidenceStatus(obj_)
# end class ContactDetailsType


class PhoneNumbers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PhoneNumber=None):
        if PhoneNumber is None:
            self.PhoneNumber = []
        else:
            self.PhoneNumber = PhoneNumber
    def factory(*args_, **kwargs_):
        if PhoneNumbers.subclass:
            return PhoneNumbers.subclass(*args_, **kwargs_)
        else:
            return PhoneNumbers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PhoneNumber(self): return self.PhoneNumber
    def set_PhoneNumber(self, PhoneNumber): self.PhoneNumber = PhoneNumber
    def add_PhoneNumber(self, value): self.PhoneNumber.append(value)
    def insert_PhoneNumber(self, index, value): self.PhoneNumber[index] = value
    def export(self, outfile, level, namespace_='', name_='PhoneNumbers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PhoneNumbers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhoneNumbers'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PhoneNumbers'):
        for PhoneNumber_ in self.PhoneNumber:
            PhoneNumber_.export(outfile, level, namespace_, name_='PhoneNumber')
    def hasContent_(self):
        if (
            self.PhoneNumber
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhoneNumbers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PhoneNumber=[\n')
        level += 1
        for PhoneNumber_ in self.PhoneNumber:
            showIndent(outfile, level)
            outfile.write('model_.PhoneNumberType(\n')
            PhoneNumber_.exportLiteral(outfile, level, name_='PhoneNumberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PhoneNumber': 
            obj_ = PhoneNumberType.factory()
            obj_.build(child_)
            self.PhoneNumber.append(obj_)
# end class PhoneNumbers


class InsurancePolicyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NewPolicy=None, PriorPolicy=None):
        self.NewPolicy = NewPolicy
        self.PriorPolicy = PriorPolicy
    def factory(*args_, **kwargs_):
        if InsurancePolicyType.subclass:
            return InsurancePolicyType.subclass(*args_, **kwargs_)
        else:
            return InsurancePolicyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NewPolicy(self): return self.NewPolicy
    def set_NewPolicy(self, NewPolicy): self.NewPolicy = NewPolicy
    def get_PriorPolicy(self): return self.PriorPolicy
    def set_PriorPolicy(self, PriorPolicy): self.PriorPolicy = PriorPolicy
    def export(self, outfile, level, namespace_='', name_='InsurancePolicyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='InsurancePolicyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InsurancePolicyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InsurancePolicyType'):
        if self.NewPolicy:
            self.NewPolicy.export(outfile, level, namespace_, name_='NewPolicy', )
        if self.PriorPolicy:
            self.PriorPolicy.export(outfile, level, namespace_, name_='PriorPolicy', )
    def hasContent_(self):
        if (
            self.NewPolicy is not None or
            self.PriorPolicy is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InsurancePolicyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.NewPolicy is not None:
            showIndent(outfile, level)
            outfile.write('NewPolicy=model_.NewPolicy(\n')
            self.NewPolicy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PriorPolicy is not None:
            showIndent(outfile, level)
            outfile.write('PriorPolicy=model_.PriorPolicy(\n')
            self.PriorPolicy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'NewPolicy': 
            obj_ = NewPolicy.factory()
            obj_.build(child_)
            self.set_NewPolicy(obj_)
        elif nodeName_ == 'PriorPolicy': 
            obj_ = PriorPolicy.factory()
            obj_.build(child_)
            self.set_PriorPolicy(obj_)
# end class InsurancePolicyType


class NewPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RequestedCoverage=None, CoverageAmount=None):
        self.RequestedCoverage = RequestedCoverage
        self.CoverageAmount = CoverageAmount
    def factory(*args_, **kwargs_):
        if NewPolicy.subclass:
            return NewPolicy.subclass(*args_, **kwargs_)
        else:
            return NewPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RequestedCoverage(self): return self.RequestedCoverage
    def set_RequestedCoverage(self, RequestedCoverage): self.RequestedCoverage = RequestedCoverage
    def validate_RequestedCoverage(self, value):
        # validate type RequestedCoverage
        pass
    def get_CoverageAmount(self): return self.CoverageAmount
    def set_CoverageAmount(self, CoverageAmount): self.CoverageAmount = CoverageAmount
    def export(self, outfile, level, namespace_='', name_='NewPolicy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='NewPolicy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NewPolicy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NewPolicy'):
        if self.RequestedCoverage is not None:
            showIndent(outfile, level)
            outfile.write('<%sRequestedCoverage>%s</%sRequestedCoverage>\n' % (namespace_, self.gds_format_string(quote_xml(self.RequestedCoverage).encode(ExternalEncoding), input_name='RequestedCoverage'), namespace_))
        if self.CoverageAmount:
            self.CoverageAmount.export(outfile, level, namespace_, name_='CoverageAmount', )
    def hasContent_(self):
        if (
            self.RequestedCoverage is not None or
            self.CoverageAmount is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NewPolicy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RequestedCoverage is not None:
            showIndent(outfile, level)
            outfile.write('RequestedCoverage=%s,\n' % quote_python(self.RequestedCoverage).encode(ExternalEncoding))
        if self.CoverageAmount is not None:
            showIndent(outfile, level)
            outfile.write('CoverageAmount=model_.HomeCoverageType(\n')
            self.CoverageAmount.exportLiteral(outfile, level, name_='CoverageAmount')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'RequestedCoverage':
            RequestedCoverage_ = child_.text
            self.RequestedCoverage = RequestedCoverage_
            self.validate_RequestedCoverage(self.RequestedCoverage)    # validate type RequestedCoverage
        elif nodeName_ == 'CoverageAmount': 
            obj_ = HomeCoverageType.factory()
            obj_.build(child_)
            self.set_CoverageAmount(obj_)
# end class NewPolicy


class PriorPolicy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CurrentlyInsured=None, InsuranceCompany=None, PolicyExpirationDate=None, YearsContinuous=None, MonthsContinuous=None):
        self.CurrentlyInsured = _cast(None, CurrentlyInsured)
        self.InsuranceCompany = InsuranceCompany
        self.PolicyExpirationDate = PolicyExpirationDate
        self.YearsContinuous = YearsContinuous
        self.MonthsContinuous = MonthsContinuous
    def factory(*args_, **kwargs_):
        if PriorPolicy.subclass:
            return PriorPolicy.subclass(*args_, **kwargs_)
        else:
            return PriorPolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_InsuranceCompany(self): return self.InsuranceCompany
    def set_InsuranceCompany(self, InsuranceCompany): self.InsuranceCompany = InsuranceCompany
    def get_PolicyExpirationDate(self): return self.PolicyExpirationDate
    def set_PolicyExpirationDate(self, PolicyExpirationDate): self.PolicyExpirationDate = PolicyExpirationDate
    def get_YearsContinuous(self): return self.YearsContinuous
    def set_YearsContinuous(self, YearsContinuous): self.YearsContinuous = YearsContinuous
    def get_MonthsContinuous(self): return self.MonthsContinuous
    def set_MonthsContinuous(self, MonthsContinuous): self.MonthsContinuous = MonthsContinuous
    def get_CurrentlyInsured(self): return self.CurrentlyInsured
    def set_CurrentlyInsured(self, CurrentlyInsured): self.CurrentlyInsured = CurrentlyInsured
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PriorPolicy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PriorPolicy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriorPolicy'):
        outfile.write(' CurrentlyInsured=%s' % (quote_attrib(self.CurrentlyInsured), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PriorPolicy'):
        if self.InsuranceCompany:
            self.InsuranceCompany.export(outfile, level, namespace_, name_='InsuranceCompany')
        if self.PolicyExpirationDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sPolicyExpirationDate>%s</%sPolicyExpirationDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.PolicyExpirationDate).encode(ExternalEncoding), input_name='PolicyExpirationDate'), namespace_))
        if self.YearsContinuous is not None:
            showIndent(outfile, level)
            outfile.write('<%sYearsContinuous>%s</%sYearsContinuous>\n' % (namespace_, self.gds_format_integer(self.YearsContinuous, input_name='YearsContinuous'), namespace_))
        if self.MonthsContinuous is not None:
            showIndent(outfile, level)
            outfile.write('<%sMonthsContinuous>%s</%sMonthsContinuous>\n' % (namespace_, self.gds_format_integer(self.MonthsContinuous, input_name='MonthsContinuous'), namespace_))
    def hasContent_(self):
        if (
            self.InsuranceCompany is not None or
            self.PolicyExpirationDate is not None or
            self.YearsContinuous is not None or
            self.MonthsContinuous is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PriorPolicy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CurrentlyInsured is not None and 'CurrentlyInsured' not in already_processed:
            already_processed.append('CurrentlyInsured')
            showIndent(outfile, level)
            outfile.write('CurrentlyInsured = "%s",\n' % (self.CurrentlyInsured,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.InsuranceCompany is not None:
            showIndent(outfile, level)
            outfile.write('InsuranceCompany=model_.InsuranceCompanyType(\n')
            self.InsuranceCompany.exportLiteral(outfile, level, name_='InsuranceCompany')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PolicyExpirationDate is not None:
            showIndent(outfile, level)
            outfile.write('PolicyExpirationDate=%s,\n' % quote_python(self.PolicyExpirationDate).encode(ExternalEncoding))
        if self.YearsContinuous is not None:
            showIndent(outfile, level)
            outfile.write('YearsContinuous=%d,\n' % self.YearsContinuous)
        if self.MonthsContinuous is not None:
            showIndent(outfile, level)
            outfile.write('MonthsContinuous=%d,\n' % self.MonthsContinuous)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('CurrentlyInsured')
        if value is not None and 'CurrentlyInsured' not in already_processed:
            already_processed.append('CurrentlyInsured')
            self.CurrentlyInsured = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'InsuranceCompany': 
            obj_ = InsuranceCompanyType.factory()
            obj_.build(child_)
            self.set_InsuranceCompany(obj_)
        elif nodeName_ == 'PolicyExpirationDate':
            PolicyExpirationDate_ = child_.text
            self.PolicyExpirationDate = PolicyExpirationDate_
        elif nodeName_ == 'YearsContinuous':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.YearsContinuous = ival_
        elif nodeName_ == 'MonthsContinuous':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.MonthsContinuous = ival_
# end class PriorPolicy


class AutoLeadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Vehicles=None, Drivers=None):
        self.Vehicles = Vehicles
        self.Drivers = Drivers
    def factory(*args_, **kwargs_):
        if AutoLeadType.subclass:
            return AutoLeadType.subclass(*args_, **kwargs_)
        else:
            return AutoLeadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vehicles(self): return self.Vehicles
    def set_Vehicles(self, Vehicles): self.Vehicles = Vehicles
    def get_Drivers(self): return self.Drivers
    def set_Drivers(self, Drivers): self.Drivers = Drivers
    def export(self, outfile, level, namespace_='', name_='AutoLeadType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='AutoLeadType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutoLeadType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AutoLeadType'):
        if self.Vehicles:
            self.Vehicles.export(outfile, level, namespace_, name_='Vehicles', )
        if self.Drivers:
            self.Drivers.export(outfile, level, namespace_, name_='Drivers', )
    def hasContent_(self):
        if (
            self.Vehicles is not None or
            self.Drivers is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AutoLeadType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Vehicles is not None:
            showIndent(outfile, level)
            outfile.write('Vehicles=model_.Vehicles(\n')
            self.Vehicles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Drivers is not None:
            showIndent(outfile, level)
            outfile.write('Drivers=model_.Drivers(\n')
            self.Drivers.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Vehicles': 
            obj_ = Vehicles.factory()
            obj_.build(child_)
            self.set_Vehicles(obj_)
        elif nodeName_ == 'Drivers': 
            obj_ = Drivers.factory()
            obj_.build(child_)
            self.set_Drivers(obj_)
# end class AutoLeadType


class Vehicles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Vehicle=None):
        if Vehicle is None:
            self.Vehicle = []
        else:
            self.Vehicle = Vehicle
    def factory(*args_, **kwargs_):
        if Vehicles.subclass:
            return Vehicles.subclass(*args_, **kwargs_)
        else:
            return Vehicles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vehicle(self): return self.Vehicle
    def set_Vehicle(self, Vehicle): self.Vehicle = Vehicle
    def add_Vehicle(self, value): self.Vehicle.append(value)
    def insert_Vehicle(self, index, value): self.Vehicle[index] = value
    def export(self, outfile, level, namespace_='', name_='Vehicles', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Vehicles')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Vehicles'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Vehicles'):
        for Vehicle_ in self.Vehicle:
            Vehicle_.export(outfile, level, namespace_, name_='Vehicle')
    def hasContent_(self):
        if (
            self.Vehicle
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Vehicles'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Vehicle=[\n')
        level += 1
        for Vehicle_ in self.Vehicle:
            showIndent(outfile, level)
            outfile.write('model_.Vehicle(\n')
            Vehicle_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Vehicle': 
            obj_ = Vehicle.factory()
            obj_.build(child_)
            self.Vehicle.append(obj_)
# end class Vehicles


class Vehicle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ownership=None, VehicleID=None, VIN=None, VehicleData=None, VehUse=None, ComphrensiveDeductible=None, CollisionDeductible=None, GarageType=None):
        self.Ownership = _cast(None, Ownership)
        self.VehicleID = _cast(int, VehicleID)
        self.VIN = VIN
        self.VehicleData = VehicleData
        self.VehUse = VehUse
        self.ComphrensiveDeductible = ComphrensiveDeductible
        self.CollisionDeductible = CollisionDeductible
        self.GarageType = GarageType
    def factory(*args_, **kwargs_):
        if Vehicle.subclass:
            return Vehicle.subclass(*args_, **kwargs_)
        else:
            return Vehicle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VIN(self): return self.VIN
    def set_VIN(self, VIN): self.VIN = VIN
    def validate_VIN(self, value):
        # validate type VIN
        pass
    def get_VehicleData(self): return self.VehicleData
    def set_VehicleData(self, VehicleData): self.VehicleData = VehicleData
    def get_VehUse(self): return self.VehUse
    def set_VehUse(self, VehUse): self.VehUse = VehUse
    def get_ComphrensiveDeductible(self): return self.ComphrensiveDeductible
    def set_ComphrensiveDeductible(self, ComphrensiveDeductible): self.ComphrensiveDeductible = ComphrensiveDeductible
    def validate_ComphrensiveDeductible(self, value):
        # validate type ComphrensiveDeductible
        pass
    def get_CollisionDeductible(self): return self.CollisionDeductible
    def set_CollisionDeductible(self, CollisionDeductible): self.CollisionDeductible = CollisionDeductible
    def validate_CollisionDeductible(self, value):
        # validate type CollisionDeductible
        pass
    def get_GarageType(self): return self.GarageType
    def set_GarageType(self, GarageType): self.GarageType = GarageType
    def validate_GarageType(self, value):
        # Validate type GarageType, a restriction on xs:string.
        pass
    def get_Ownership(self): return self.Ownership
    def set_Ownership(self, Ownership): self.Ownership = Ownership
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def get_VehicleID(self): return self.VehicleID
    def set_VehicleID(self, VehicleID): self.VehicleID = VehicleID
    def export(self, outfile, level, namespace_='', name_='Vehicle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Vehicle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Vehicle'):
        outfile.write(' Ownership=%s' % (quote_attrib(self.Ownership), ))
        outfile.write(' VehicleID="%s"' % self.gds_format_integer(self.VehicleID, input_name='VehicleID'))
    def exportChildren(self, outfile, level, namespace_='', name_='Vehicle'):
        if self.VIN is not None:
            showIndent(outfile, level)
            outfile.write('<%sVIN>%s</%sVIN>\n' % (namespace_, self.gds_format_string(quote_xml(self.VIN).encode(ExternalEncoding), input_name='VIN'), namespace_))
        if self.VehicleData:
            self.VehicleData.export(outfile, level, namespace_, name_='VehicleData', )
        if self.VehUse:
            self.VehUse.export(outfile, level, namespace_, name_='VehUse', )
        if self.ComphrensiveDeductible is not None:
            showIndent(outfile, level)
            outfile.write('<%sComphrensiveDeductible>%s</%sComphrensiveDeductible>\n' % (namespace_, self.gds_format_string(quote_xml(self.ComphrensiveDeductible).encode(ExternalEncoding), input_name='ComphrensiveDeductible'), namespace_))
        if self.CollisionDeductible is not None:
            showIndent(outfile, level)
            outfile.write('<%sCollisionDeductible>%s</%sCollisionDeductible>\n' % (namespace_, self.gds_format_string(quote_xml(self.CollisionDeductible).encode(ExternalEncoding), input_name='CollisionDeductible'), namespace_))
        if self.GarageType is not None:
            showIndent(outfile, level)
            outfile.write('<%sGarageType>%s</%sGarageType>\n' % (namespace_, self.gds_format_string(quote_xml(self.GarageType).encode(ExternalEncoding), input_name='GarageType'), namespace_))
    def hasContent_(self):
        if (
            self.VIN is not None or
            self.VehicleData is not None or
            self.VehUse is not None or
            self.ComphrensiveDeductible is not None or
            self.CollisionDeductible is not None or
            self.GarageType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Vehicle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Ownership is not None and 'Ownership' not in already_processed:
            already_processed.append('Ownership')
            showIndent(outfile, level)
            outfile.write('Ownership = "%s",\n' % (self.Ownership,))
        if self.VehicleID is not None and 'VehicleID' not in already_processed:
            already_processed.append('VehicleID')
            showIndent(outfile, level)
            outfile.write('VehicleID = %d,\n' % (self.VehicleID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VIN is not None:
            showIndent(outfile, level)
            outfile.write('VIN=%s,\n' % quote_python(self.VIN).encode(ExternalEncoding))
        if self.VehicleData is not None:
            showIndent(outfile, level)
            outfile.write('VehicleData=model_.VehicleData(\n')
            self.VehicleData.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VehUse is not None:
            showIndent(outfile, level)
            outfile.write('VehUse=model_.VehUseType(\n')
            self.VehUse.exportLiteral(outfile, level, name_='VehUse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComphrensiveDeductible is not None:
            showIndent(outfile, level)
            outfile.write('ComphrensiveDeductible=%s,\n' % quote_python(self.ComphrensiveDeductible).encode(ExternalEncoding))
        if self.CollisionDeductible is not None:
            showIndent(outfile, level)
            outfile.write('CollisionDeductible=%s,\n' % quote_python(self.CollisionDeductible).encode(ExternalEncoding))
        if self.GarageType is not None:
            showIndent(outfile, level)
            outfile.write('GarageType=%s,\n' % quote_python(self.GarageType).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Ownership')
        if value is not None and 'Ownership' not in already_processed:
            already_processed.append('Ownership')
            self.Ownership = value
        value = attrs.get('VehicleID')
        if value is not None and 'VehicleID' not in already_processed:
            already_processed.append('VehicleID')
            try:
                self.VehicleID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'VIN':
            VIN_ = child_.text
            self.VIN = VIN_
            self.validate_VIN(self.VIN)    # validate type VIN
        elif nodeName_ == 'VehicleData': 
            obj_ = VehicleData.factory()
            obj_.build(child_)
            self.set_VehicleData(obj_)
        elif nodeName_ == 'VehUse': 
            obj_ = VehUseType.factory()
            obj_.build(child_)
            self.set_VehUse(obj_)
        elif nodeName_ == 'ComphrensiveDeductible':
            ComphrensiveDeductible_ = child_.text
            self.ComphrensiveDeductible = ComphrensiveDeductible_
            self.validate_ComphrensiveDeductible(self.ComphrensiveDeductible)    # validate type ComphrensiveDeductible
        elif nodeName_ == 'CollisionDeductible':
            CollisionDeductible_ = child_.text
            self.CollisionDeductible = CollisionDeductible_
            self.validate_CollisionDeductible(self.CollisionDeductible)    # validate type CollisionDeductible
        elif nodeName_ == 'GarageType':
            GarageType_ = child_.text
            self.GarageType = GarageType_
            self.validate_GarageType(self.GarageType)    # validate type GarageType
# end class Vehicle


class VehicleData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, VehYear=None, VehMake=None, VehModel=None, VehSubmodel=None):
        self.VehYear = VehYear
        self.VehMake = VehMake
        self.VehModel = VehModel
        self.VehSubmodel = VehSubmodel
    def factory(*args_, **kwargs_):
        if VehicleData.subclass:
            return VehicleData.subclass(*args_, **kwargs_)
        else:
            return VehicleData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VehYear(self): return self.VehYear
    def set_VehYear(self, VehYear): self.VehYear = VehYear
    def validate_VehYear(self, value):
        # validate type VehYear
        pass
    def get_VehMake(self): return self.VehMake
    def set_VehMake(self, VehMake): self.VehMake = VehMake
    def validate_VehMake(self, value):
        # validate type VehMake
        pass
    def get_VehModel(self): return self.VehModel
    def set_VehModel(self, VehModel): self.VehModel = VehModel
    def validate_VehModel(self, value):
        # validate type VehModel
        pass
    def get_VehSubmodel(self): return self.VehSubmodel
    def set_VehSubmodel(self, VehSubmodel): self.VehSubmodel = VehSubmodel
    def export(self, outfile, level, namespace_='', name_='VehicleData', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='VehicleData')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VehicleData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VehicleData'):
        if self.VehYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sVehYear>%s</%sVehYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.VehYear).encode(ExternalEncoding), input_name='VehYear'), namespace_))
        if self.VehMake is not None:
            showIndent(outfile, level)
            outfile.write('<%sVehMake>%s</%sVehMake>\n' % (namespace_, self.gds_format_string(quote_xml(self.VehMake).encode(ExternalEncoding), input_name='VehMake'), namespace_))
        if self.VehModel is not None:
            showIndent(outfile, level)
            outfile.write('<%sVehModel>%s</%sVehModel>\n' % (namespace_, self.gds_format_string(quote_xml(self.VehModel).encode(ExternalEncoding), input_name='VehModel'), namespace_))
        if self.VehSubmodel is not None:
            showIndent(outfile, level)
            outfile.write('<%sVehSubmodel>%s</%sVehSubmodel>\n' % (namespace_, self.gds_format_string(quote_xml(self.VehSubmodel).encode(ExternalEncoding), input_name='VehSubmodel'), namespace_))
    def hasContent_(self):
        if (
            self.VehYear is not None or
            self.VehMake is not None or
            self.VehModel is not None or
            self.VehSubmodel is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VehicleData'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.VehYear is not None:
            showIndent(outfile, level)
            outfile.write('VehYear=%s,\n' % quote_python(self.VehYear).encode(ExternalEncoding))
        if self.VehMake is not None:
            showIndent(outfile, level)
            outfile.write('VehMake=%s,\n' % quote_python(self.VehMake).encode(ExternalEncoding))
        if self.VehModel is not None:
            showIndent(outfile, level)
            outfile.write('VehModel=%s,\n' % quote_python(self.VehModel).encode(ExternalEncoding))
        if self.VehSubmodel is not None:
            showIndent(outfile, level)
            outfile.write('VehSubmodel=%s,\n' % quote_python(self.VehSubmodel).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'VehYear':
            VehYear_ = child_.text
            self.VehYear = VehYear_
            self.validate_VehYear(self.VehYear)    # validate type VehYear
        elif nodeName_ == 'VehMake':
            VehMake_ = child_.text
            self.VehMake = VehMake_
            self.validate_VehMake(self.VehMake)    # validate type VehMake
        elif nodeName_ == 'VehModel':
            VehModel_ = child_.text
            self.VehModel = VehModel_
            self.validate_VehModel(self.VehModel)    # validate type VehModel
        elif nodeName_ == 'VehSubmodel':
            VehSubmodel_ = child_.text
            self.VehSubmodel = VehSubmodel_
# end class VehicleData


class Drivers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Driver=None):
        if Driver is None:
            self.Driver = []
        else:
            self.Driver = Driver
    def factory(*args_, **kwargs_):
        if Drivers.subclass:
            return Drivers.subclass(*args_, **kwargs_)
        else:
            return Drivers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Driver(self): return self.Driver
    def set_Driver(self, Driver): self.Driver = Driver
    def add_Driver(self, value): self.Driver.append(value)
    def insert_Driver(self, index, value): self.Driver[index] = value
    def export(self, outfile, level, namespace_='', name_='Drivers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Drivers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Drivers'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Drivers'):
        for Driver_ in self.Driver:
            Driver_.export(outfile, level, namespace_, name_='Driver')
    def hasContent_(self):
        if (
            self.Driver
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Drivers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Driver=[\n')
        level += 1
        for Driver_ in self.Driver:
            showIndent(outfile, level)
            outfile.write('model_.Driver(\n')
            Driver_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Driver': 
            obj_ = Driver.factory()
            obj_.build(child_)
            self.Driver.append(obj_)
# end class Drivers


class Driver(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DriverID=None, PersonalInfo=None, PrimaryVehicle=None, DriversLicense=None, DrivingRecord=None):
        self.DriverID = _cast(int, DriverID)
        self.PersonalInfo = PersonalInfo
        self.PrimaryVehicle = PrimaryVehicle
        self.DriversLicense = DriversLicense
        self.DrivingRecord = DrivingRecord
    def factory(*args_, **kwargs_):
        if Driver.subclass:
            return Driver.subclass(*args_, **kwargs_)
        else:
            return Driver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonalInfo(self): return self.PersonalInfo
    def set_PersonalInfo(self, PersonalInfo): self.PersonalInfo = PersonalInfo
    def get_PrimaryVehicle(self): return self.PrimaryVehicle
    def set_PrimaryVehicle(self, PrimaryVehicle): self.PrimaryVehicle = PrimaryVehicle
    def get_DriversLicense(self): return self.DriversLicense
    def set_DriversLicense(self, DriversLicense): self.DriversLicense = DriversLicense
    def get_DrivingRecord(self): return self.DrivingRecord
    def set_DrivingRecord(self, DrivingRecord): self.DrivingRecord = DrivingRecord
    def get_DriverID(self): return self.DriverID
    def set_DriverID(self, DriverID): self.DriverID = DriverID
    def export(self, outfile, level, namespace_='', name_='Driver', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Driver')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Driver'):
        outfile.write(' DriverID="%s"' % self.gds_format_integer(self.DriverID, input_name='DriverID'))
    def exportChildren(self, outfile, level, namespace_='', name_='Driver'):
        if self.PersonalInfo:
            self.PersonalInfo.export(outfile, level, namespace_, name_='PersonalInfo', )
        if self.PrimaryVehicle is not None:
            showIndent(outfile, level)
            outfile.write('<%sPrimaryVehicle>%s</%sPrimaryVehicle>\n' % (namespace_, self.gds_format_integer(self.PrimaryVehicle, input_name='PrimaryVehicle'), namespace_))
        if self.DriversLicense:
            self.DriversLicense.export(outfile, level, namespace_, name_='DriversLicense', )
        if self.DrivingRecord:
            self.DrivingRecord.export(outfile, level, namespace_, name_='DrivingRecord', )
    def hasContent_(self):
        if (
            self.PersonalInfo is not None or
            self.PrimaryVehicle is not None or
            self.DriversLicense is not None or
            self.DrivingRecord is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Driver'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.DriverID is not None and 'DriverID' not in already_processed:
            already_processed.append('DriverID')
            showIndent(outfile, level)
            outfile.write('DriverID = %d,\n' % (self.DriverID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PersonalInfo is not None:
            showIndent(outfile, level)
            outfile.write('PersonalInfo=model_.PersonalInfo(\n')
            self.PersonalInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PrimaryVehicle is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryVehicle=%d,\n' % self.PrimaryVehicle)
        if self.DriversLicense is not None:
            showIndent(outfile, level)
            outfile.write('DriversLicense=model_.DriversLicense(\n')
            self.DriversLicense.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DrivingRecord is not None:
            showIndent(outfile, level)
            outfile.write('DrivingRecord=model_.DrivingRecord(\n')
            self.DrivingRecord.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('DriverID')
        if value is not None and 'DriverID' not in already_processed:
            already_processed.append('DriverID')
            try:
                self.DriverID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PersonalInfo': 
            obj_ = PersonalInfo.factory()
            obj_.build(child_)
            self.set_PersonalInfo(obj_)
        elif nodeName_ == 'PrimaryVehicle':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.PrimaryVehicle = ival_
        elif nodeName_ == 'DriversLicense': 
            obj_ = DriversLicense.factory()
            obj_.build(child_)
            self.set_DriversLicense(obj_)
        elif nodeName_ == 'DrivingRecord': 
            obj_ = DrivingRecord.factory()
            obj_.build(child_)
            self.set_DrivingRecord(obj_)
# end class Driver


class PersonalInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PersonID=None, Gender=None, MaritalStatus=None, RelationshipToApplicant=None, FirstName=None, LastName=None, BirthDate=None, SocialSecurityNumber=None, Occupation=None, MilitaryExperience=None, Education=None, CreditRating=None):
        self.PersonID = _cast(int, PersonID)
        self.Gender = _cast(None, Gender)
        self.MaritalStatus = _cast(None, MaritalStatus)
        self.RelationshipToApplicant = _cast(None, RelationshipToApplicant)
        self.FirstName = FirstName
        self.LastName = LastName
        self.BirthDate = BirthDate
        self.SocialSecurityNumber = SocialSecurityNumber
        self.Occupation = Occupation
        self.MilitaryExperience = MilitaryExperience
        self.Education = Education
        self.CreditRating = CreditRating
    def factory(*args_, **kwargs_):
        if PersonalInfo.subclass:
            return PersonalInfo.subclass(*args_, **kwargs_)
        else:
            return PersonalInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_SocialSecurityNumber(self): return self.SocialSecurityNumber
    def set_SocialSecurityNumber(self, SocialSecurityNumber): self.SocialSecurityNumber = SocialSecurityNumber
    def get_Occupation(self): return self.Occupation
    def set_Occupation(self, Occupation): self.Occupation = Occupation
    def validate_Occupation(self, value):
        # validate type Occupation
        pass
    def get_MilitaryExperience(self): return self.MilitaryExperience
    def set_MilitaryExperience(self, MilitaryExperience): self.MilitaryExperience = MilitaryExperience
    def validate_MilitaryExperience(self, value):
        # validate type MilitaryExperience
        pass
    def get_Education(self): return self.Education
    def set_Education(self, Education): self.Education = Education
    def get_CreditRating(self): return self.CreditRating
    def set_CreditRating(self, CreditRating): self.CreditRating = CreditRating
    def get_PersonID(self): return self.PersonID
    def set_PersonID(self, PersonID): self.PersonID = PersonID
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def validate_GenderType(self, value):
        # Validate type GenderType, a restriction on xs:string.
        pass
    def get_MaritalStatus(self): return self.MaritalStatus
    def set_MaritalStatus(self, MaritalStatus): self.MaritalStatus = MaritalStatus
    def validate_MaritalStatusType(self, value):
        # Validate type MaritalStatusType, a restriction on xs:string.
        pass
    def get_RelationshipToApplicant(self): return self.RelationshipToApplicant
    def set_RelationshipToApplicant(self, RelationshipToApplicant): self.RelationshipToApplicant = RelationshipToApplicant
    def validate_RelationshipToApplicantType(self, value):
        # Validate type RelationshipToApplicantType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PersonalInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PersonalInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonalInfo'):
        if self.PersonID is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            outfile.write(' PersonID="%s"' % self.gds_format_integer(self.PersonID, input_name='PersonID'))
        outfile.write(' Gender=%s' % (quote_attrib(self.Gender), ))
        outfile.write(' MaritalStatus=%s' % (quote_attrib(self.MaritalStatus), ))
        outfile.write(' RelationshipToApplicant=%s' % (quote_attrib(self.RelationshipToApplicant), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonalInfo'):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('<%sFirstName>%s</%sFirstName>\n' % (namespace_, self.gds_format_string(quote_xml(self.FirstName).encode(ExternalEncoding), input_name='FirstName'), namespace_))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastName>%s</%sLastName>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastName).encode(ExternalEncoding), input_name='LastName'), namespace_))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        if self.SocialSecurityNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sSocialSecurityNumber>%s</%sSocialSecurityNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.SocialSecurityNumber).encode(ExternalEncoding), input_name='SocialSecurityNumber'), namespace_))
        if self.Occupation is not None:
            showIndent(outfile, level)
            outfile.write('<%sOccupation>%s</%sOccupation>\n' % (namespace_, self.gds_format_string(quote_xml(self.Occupation).encode(ExternalEncoding), input_name='Occupation'), namespace_))
        if self.MilitaryExperience is not None:
            showIndent(outfile, level)
            outfile.write('<%sMilitaryExperience>%s</%sMilitaryExperience>\n' % (namespace_, self.gds_format_string(quote_xml(self.MilitaryExperience).encode(ExternalEncoding), input_name='MilitaryExperience'), namespace_))
        if self.Education:
            self.Education.export(outfile, level, namespace_, name_='Education', )
        if self.CreditRating:
            self.CreditRating.export(outfile, level, namespace_, name_='CreditRating', )
    def hasContent_(self):
        if (
            self.FirstName is not None or
            self.LastName is not None or
            self.BirthDate is not None or
            self.SocialSecurityNumber is not None or
            self.Occupation is not None or
            self.MilitaryExperience is not None or
            self.Education is not None or
            self.CreditRating is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonalInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PersonID is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            showIndent(outfile, level)
            outfile.write('PersonID = %d,\n' % (self.PersonID,))
        if self.Gender is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            showIndent(outfile, level)
            outfile.write('Gender = "%s",\n' % (self.Gender,))
        if self.MaritalStatus is not None and 'MaritalStatus' not in already_processed:
            already_processed.append('MaritalStatus')
            showIndent(outfile, level)
            outfile.write('MaritalStatus = "%s",\n' % (self.MaritalStatus,))
        if self.RelationshipToApplicant is not None and 'RelationshipToApplicant' not in already_processed:
            already_processed.append('RelationshipToApplicant')
            showIndent(outfile, level)
            outfile.write('RelationshipToApplicant = "%s",\n' % (self.RelationshipToApplicant,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('FirstName=%s,\n' % quote_python(self.FirstName).encode(ExternalEncoding))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('LastName=%s,\n' % quote_python(self.LastName).encode(ExternalEncoding))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        if self.SocialSecurityNumber is not None:
            showIndent(outfile, level)
            outfile.write('SocialSecurityNumber=%s,\n' % quote_python(self.SocialSecurityNumber).encode(ExternalEncoding))
        if self.Occupation is not None:
            showIndent(outfile, level)
            outfile.write('Occupation=%s,\n' % quote_python(self.Occupation).encode(ExternalEncoding))
        if self.MilitaryExperience is not None:
            showIndent(outfile, level)
            outfile.write('MilitaryExperience=%s,\n' % quote_python(self.MilitaryExperience).encode(ExternalEncoding))
        if self.Education is not None:
            showIndent(outfile, level)
            outfile.write('Education=model_.EducationType(\n')
            self.Education.exportLiteral(outfile, level, name_='Education')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CreditRating is not None:
            showIndent(outfile, level)
            outfile.write('CreditRating=model_.CreditRatingType(\n')
            self.CreditRating.exportLiteral(outfile, level, name_='CreditRating')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('PersonID')
        if value is not None and 'PersonID' not in already_processed:
            already_processed.append('PersonID')
            try:
                self.PersonID = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('Gender')
        if value is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            self.Gender = value
        value = attrs.get('MaritalStatus')
        if value is not None and 'MaritalStatus' not in already_processed:
            already_processed.append('MaritalStatus')
            self.MaritalStatus = value
        value = attrs.get('RelationshipToApplicant')
        if value is not None and 'RelationshipToApplicant' not in already_processed:
            already_processed.append('RelationshipToApplicant')
            self.RelationshipToApplicant = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'FirstName':
            FirstName_ = child_.text
            self.FirstName = FirstName_
        elif nodeName_ == 'LastName':
            LastName_ = child_.text
            self.LastName = LastName_
        elif nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            self.BirthDate = BirthDate_
        elif nodeName_ == 'SocialSecurityNumber':
            SocialSecurityNumber_ = child_.text
            self.SocialSecurityNumber = SocialSecurityNumber_
        elif nodeName_ == 'Occupation':
            Occupation_ = child_.text
            self.Occupation = Occupation_
            self.validate_Occupation(self.Occupation)    # validate type Occupation
        elif nodeName_ == 'MilitaryExperience':
            MilitaryExperience_ = child_.text
            self.MilitaryExperience = MilitaryExperience_
            self.validate_MilitaryExperience(self.MilitaryExperience)    # validate type MilitaryExperience
        elif nodeName_ == 'Education': 
            obj_ = EducationType.factory()
            obj_.build(child_)
            self.set_Education(obj_)
        elif nodeName_ == 'CreditRating': 
            obj_ = CreditRatingType.factory()
            obj_.build(child_)
            self.set_CreditRating(obj_)
# end class PersonalInfo


class DriversLicense(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LicenseEverSuspendedRevoked=None, State=None, Number=None, LicensedAge=None):
        self.LicenseEverSuspendedRevoked = _cast(None, LicenseEverSuspendedRevoked)
        self.State = State
        self.Number = Number
        self.LicensedAge = LicensedAge
    def factory(*args_, **kwargs_):
        if DriversLicense.subclass:
            return DriversLicense.subclass(*args_, **kwargs_)
        else:
            return DriversLicense(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    def validate_State(self, value):
        # validate type State
        pass
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def get_LicensedAge(self): return self.LicensedAge
    def set_LicensedAge(self, LicensedAge): self.LicensedAge = LicensedAge
    def get_LicenseEverSuspendedRevoked(self): return self.LicenseEverSuspendedRevoked
    def set_LicenseEverSuspendedRevoked(self, LicenseEverSuspendedRevoked): self.LicenseEverSuspendedRevoked = LicenseEverSuspendedRevoked
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='DriversLicense', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='DriversLicense')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DriversLicense'):
        outfile.write(' LicenseEverSuspendedRevoked=%s' % (quote_attrib(self.LicenseEverSuspendedRevoked), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DriversLicense'):
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('<%sState>%s</%sState>\n' % (namespace_, self.gds_format_string(quote_xml(self.State).encode(ExternalEncoding), input_name='State'), namespace_))
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumber>%s</%sNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.Number).encode(ExternalEncoding), input_name='Number'), namespace_))
        if self.LicensedAge is not None:
            showIndent(outfile, level)
            outfile.write('<%sLicensedAge>%s</%sLicensedAge>\n' % (namespace_, self.gds_format_string(quote_xml(self.LicensedAge).encode(ExternalEncoding), input_name='LicensedAge'), namespace_))
    def hasContent_(self):
        if (
            self.State is not None or
            self.Number is not None or
            self.LicensedAge is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DriversLicense'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.LicenseEverSuspendedRevoked is not None and 'LicenseEverSuspendedRevoked' not in already_processed:
            already_processed.append('LicenseEverSuspendedRevoked')
            showIndent(outfile, level)
            outfile.write('LicenseEverSuspendedRevoked = "%s",\n' % (self.LicenseEverSuspendedRevoked,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('State=%s,\n' % quote_python(self.State).encode(ExternalEncoding))
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('Number=%s,\n' % quote_python(self.Number).encode(ExternalEncoding))
        if self.LicensedAge is not None:
            showIndent(outfile, level)
            outfile.write('LicensedAge=%s,\n' % quote_python(self.LicensedAge).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('LicenseEverSuspendedRevoked')
        if value is not None and 'LicenseEverSuspendedRevoked' not in already_processed:
            already_processed.append('LicenseEverSuspendedRevoked')
            self.LicenseEverSuspendedRevoked = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'State':
            State_ = child_.text
            self.State = State_
            self.validate_State(self.State)    # validate type State
        elif nodeName_ == 'Number':
            Number_ = child_.text
            self.Number = Number_
        elif nodeName_ == 'LicensedAge':
            LicensedAge_ = child_.text
            self.LicensedAge = LicensedAge_
# end class DriversLicense


class DrivingRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SR22Required=None, DriverTraining=None, DUIs=None, Accidents=None, Tickets=None, Claims=None):
        self.SR22Required = _cast(None, SR22Required)
        self.DriverTraining = _cast(None, DriverTraining)
        self.DUIs = DUIs
        self.Accidents = Accidents
        self.Tickets = Tickets
        self.Claims = Claims
    def factory(*args_, **kwargs_):
        if DrivingRecord.subclass:
            return DrivingRecord.subclass(*args_, **kwargs_)
        else:
            return DrivingRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DUIs(self): return self.DUIs
    def set_DUIs(self, DUIs): self.DUIs = DUIs
    def get_Accidents(self): return self.Accidents
    def set_Accidents(self, Accidents): self.Accidents = Accidents
    def get_Tickets(self): return self.Tickets
    def set_Tickets(self, Tickets): self.Tickets = Tickets
    def get_Claims(self): return self.Claims
    def set_Claims(self, Claims): self.Claims = Claims
    def get_SR22Required(self): return self.SR22Required
    def set_SR22Required(self, SR22Required): self.SR22Required = SR22Required
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def get_DriverTraining(self): return self.DriverTraining
    def set_DriverTraining(self, DriverTraining): self.DriverTraining = DriverTraining
    def export(self, outfile, level, namespace_='', name_='DrivingRecord', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='DrivingRecord')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DrivingRecord'):
        outfile.write(' SR22Required=%s' % (quote_attrib(self.SR22Required), ))
        outfile.write(' DriverTraining=%s' % (quote_attrib(self.DriverTraining), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DrivingRecord'):
        if self.DUIs:
            self.DUIs.export(outfile, level, namespace_, name_='DUIs')
        if self.Accidents:
            self.Accidents.export(outfile, level, namespace_, name_='Accidents')
        if self.Tickets:
            self.Tickets.export(outfile, level, namespace_, name_='Tickets')
        if self.Claims:
            self.Claims.export(outfile, level, namespace_, name_='Claims')
    def hasContent_(self):
        if (
            self.DUIs is not None or
            self.Accidents is not None or
            self.Tickets is not None or
            self.Claims is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DrivingRecord'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.SR22Required is not None and 'SR22Required' not in already_processed:
            already_processed.append('SR22Required')
            showIndent(outfile, level)
            outfile.write('SR22Required = "%s",\n' % (self.SR22Required,))
        if self.DriverTraining is not None and 'DriverTraining' not in already_processed:
            already_processed.append('DriverTraining')
            showIndent(outfile, level)
            outfile.write('DriverTraining = "%s",\n' % (self.DriverTraining,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DUIs is not None:
            showIndent(outfile, level)
            outfile.write('DUIs=model_.DUIs(\n')
            self.DUIs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Accidents is not None:
            showIndent(outfile, level)
            outfile.write('Accidents=model_.Accidents(\n')
            self.Accidents.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Tickets is not None:
            showIndent(outfile, level)
            outfile.write('Tickets=model_.Tickets(\n')
            self.Tickets.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Claims is not None:
            showIndent(outfile, level)
            outfile.write('Claims=model_.Claims(\n')
            self.Claims.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('SR22Required')
        if value is not None and 'SR22Required' not in already_processed:
            already_processed.append('SR22Required')
            self.SR22Required = value
        value = attrs.get('DriverTraining')
        if value is not None and 'DriverTraining' not in already_processed:
            already_processed.append('DriverTraining')
            self.DriverTraining = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'DUIs': 
            obj_ = DUIs.factory()
            obj_.build(child_)
            self.set_DUIs(obj_)
        elif nodeName_ == 'Accidents': 
            obj_ = Accidents.factory()
            obj_.build(child_)
            self.set_Accidents(obj_)
        elif nodeName_ == 'Tickets': 
            obj_ = Tickets.factory()
            obj_.build(child_)
            self.set_Tickets(obj_)
        elif nodeName_ == 'Claims': 
            obj_ = Claims.factory()
            obj_.build(child_)
            self.set_Claims(obj_)
# end class DrivingRecord


class DUIs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DUI=None):
        if DUI is None:
            self.DUI = []
        else:
            self.DUI = DUI
    def factory(*args_, **kwargs_):
        if DUIs.subclass:
            return DUIs.subclass(*args_, **kwargs_)
        else:
            return DUIs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DUI(self): return self.DUI
    def set_DUI(self, DUI): self.DUI = DUI
    def add_DUI(self, value): self.DUI.append(value)
    def insert_DUI(self, index, value): self.DUI[index] = value
    def export(self, outfile, level, namespace_='', name_='DUIs', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='DUIs')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DUIs'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DUIs'):
        for DUI_ in self.DUI:
            DUI_.export(outfile, level, namespace_, name_='DUI')
    def hasContent_(self):
        if (
            self.DUI
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DUIs'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DUI=[\n')
        level += 1
        for DUI_ in self.DUI:
            showIndent(outfile, level)
            outfile.write('model_.DUI(\n')
            DUI_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'DUI': 
            obj_ = DUI.factory()
            obj_.build(child_)
            self.DUI.append(obj_)
# end class DUIs


class DUI(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Month=None, Year=None, State=None):
        self.Month = _cast(None, Month)
        self.Year = _cast(None, Year)
        self.State = State
    def factory(*args_, **kwargs_):
        if DUI.subclass:
            return DUI.subclass(*args_, **kwargs_)
        else:
            return DUI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_State(self): return self.State
    def set_State(self, State): self.State = State
    def validate_State(self, value):
        # validate type State
        pass
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def validate_MonthType(self, value):
        # Validate type MonthType, a restriction on xs:string.
        pass
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def validate_YearType(self, value):
        # Validate type YearType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='DUI', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='DUI')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DUI'):
        outfile.write(' Month=%s' % (quote_attrib(self.Month), ))
        outfile.write(' Year=%s' % (quote_attrib(self.Year), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DUI'):
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('<%sState>%s</%sState>\n' % (namespace_, self.gds_format_string(quote_xml(self.State).encode(ExternalEncoding), input_name='State'), namespace_))
    def hasContent_(self):
        if (
            self.State is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DUI'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Month is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            showIndent(outfile, level)
            outfile.write('Month = "%s",\n' % (self.Month,))
        if self.Year is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            showIndent(outfile, level)
            outfile.write('Year = "%s",\n' % (self.Year,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.State is not None:
            showIndent(outfile, level)
            outfile.write('State=%s,\n' % quote_python(self.State).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Month')
        if value is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            self.Month = value
        value = attrs.get('Year')
        if value is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            self.Year = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'State':
            State_ = child_.text
            self.State = State_
            self.validate_State(self.State)    # validate type State
# end class DUI


class Accidents(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Accident=None):
        if Accident is None:
            self.Accident = []
        else:
            self.Accident = Accident
    def factory(*args_, **kwargs_):
        if Accidents.subclass:
            return Accidents.subclass(*args_, **kwargs_)
        else:
            return Accidents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Accident(self): return self.Accident
    def set_Accident(self, Accident): self.Accident = Accident
    def add_Accident(self, value): self.Accident.append(value)
    def insert_Accident(self, index, value): self.Accident[index] = value
    def export(self, outfile, level, namespace_='', name_='Accidents', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Accidents')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Accidents'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Accidents'):
        for Accident_ in self.Accident:
            Accident_.export(outfile, level, namespace_, name_='Accident')
    def hasContent_(self):
        if (
            self.Accident
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Accidents'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Accident=[\n')
        level += 1
        for Accident_ in self.Accident:
            showIndent(outfile, level)
            outfile.write('model_.Accident(\n')
            Accident_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Accident': 
            obj_ = Accident.factory()
            obj_.build(child_)
            self.Accident.append(obj_)
# end class Accidents


class Accident(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Month=None, Year=None, Description=None, AtFault=None, WhatDamaged=None, InsurancePaidAmount=None):
        self.Month = _cast(None, Month)
        self.Year = _cast(None, Year)
        self.Description = Description
        self.AtFault = AtFault
        self.WhatDamaged = WhatDamaged
        self.InsurancePaidAmount = InsurancePaidAmount
    def factory(*args_, **kwargs_):
        if Accident.subclass:
            return Accident.subclass(*args_, **kwargs_)
        else:
            return Accident(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_Description(self, value):
        # validate type Description
        pass
    def get_AtFault(self): return self.AtFault
    def set_AtFault(self, AtFault): self.AtFault = AtFault
    def validate_AtFault(self, value):
        # validate type AtFault
        pass
    def get_WhatDamaged(self): return self.WhatDamaged
    def set_WhatDamaged(self, WhatDamaged): self.WhatDamaged = WhatDamaged
    def validate_WhatDamaged(self, value):
        # Validate type WhatDamaged, a restriction on xs:string.
        pass
    def get_InsurancePaidAmount(self): return self.InsurancePaidAmount
    def set_InsurancePaidAmount(self, InsurancePaidAmount): self.InsurancePaidAmount = InsurancePaidAmount
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def validate_MonthType(self, value):
        # Validate type MonthType, a restriction on xs:string.
        pass
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def validate_YearType(self, value):
        # Validate type YearType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Accident', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Accident')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Accident'):
        outfile.write(' Month=%s' % (quote_attrib(self.Month), ))
        outfile.write(' Year=%s' % (quote_attrib(self.Year), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Accident'):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.AtFault is not None:
            showIndent(outfile, level)
            outfile.write('<%sAtFault>%s</%sAtFault>\n' % (namespace_, self.gds_format_string(quote_xml(self.AtFault).encode(ExternalEncoding), input_name='AtFault'), namespace_))
        if self.WhatDamaged is not None:
            showIndent(outfile, level)
            outfile.write('<%sWhatDamaged>%s</%sWhatDamaged>\n' % (namespace_, self.gds_format_string(quote_xml(self.WhatDamaged).encode(ExternalEncoding), input_name='WhatDamaged'), namespace_))
        if self.InsurancePaidAmount is not None:
            showIndent(outfile, level)
            outfile.write('<%sInsurancePaidAmount>%s</%sInsurancePaidAmount>\n' % (namespace_, self.gds_format_integer(self.InsurancePaidAmount, input_name='InsurancePaidAmount'), namespace_))
    def hasContent_(self):
        if (
            self.Description is not None or
            self.AtFault is not None or
            self.WhatDamaged is not None or
            self.InsurancePaidAmount is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Accident'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Month is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            showIndent(outfile, level)
            outfile.write('Month = "%s",\n' % (self.Month,))
        if self.Year is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            showIndent(outfile, level)
            outfile.write('Year = "%s",\n' % (self.Year,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.AtFault is not None:
            showIndent(outfile, level)
            outfile.write('AtFault=%s,\n' % quote_python(self.AtFault).encode(ExternalEncoding))
        if self.WhatDamaged is not None:
            showIndent(outfile, level)
            outfile.write('WhatDamaged=%s,\n' % quote_python(self.WhatDamaged).encode(ExternalEncoding))
        if self.InsurancePaidAmount is not None:
            showIndent(outfile, level)
            outfile.write('InsurancePaidAmount=%d,\n' % self.InsurancePaidAmount)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Month')
        if value is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            self.Month = value
        value = attrs.get('Year')
        if value is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            self.Year = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            self.Description = Description_
            self.validate_Description(self.Description)    # validate type Description
        elif nodeName_ == 'AtFault':
            AtFault_ = child_.text
            self.AtFault = AtFault_
            self.validate_AtFault(self.AtFault)    # validate type AtFault
        elif nodeName_ == 'WhatDamaged':
            WhatDamaged_ = child_.text
            self.WhatDamaged = WhatDamaged_
            self.validate_WhatDamaged(self.WhatDamaged)    # validate type WhatDamaged
        elif nodeName_ == 'InsurancePaidAmount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.InsurancePaidAmount = ival_
# end class Accident


class Tickets(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Ticket=None):
        if Ticket is None:
            self.Ticket = []
        else:
            self.Ticket = Ticket
    def factory(*args_, **kwargs_):
        if Tickets.subclass:
            return Tickets.subclass(*args_, **kwargs_)
        else:
            return Tickets(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ticket(self): return self.Ticket
    def set_Ticket(self, Ticket): self.Ticket = Ticket
    def add_Ticket(self, value): self.Ticket.append(value)
    def insert_Ticket(self, index, value): self.Ticket[index] = value
    def export(self, outfile, level, namespace_='', name_='Tickets', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Tickets')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Tickets'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Tickets'):
        for Ticket_ in self.Ticket:
            Ticket_.export(outfile, level, namespace_, name_='Ticket')
    def hasContent_(self):
        if (
            self.Ticket
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Tickets'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Ticket=[\n')
        level += 1
        for Ticket_ in self.Ticket:
            showIndent(outfile, level)
            outfile.write('model_.Ticket(\n')
            Ticket_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Ticket': 
            obj_ = Ticket.factory()
            obj_.build(child_)
            self.Ticket.append(obj_)
# end class Tickets


class Ticket(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Month=None, Year=None, Description=None):
        self.Month = _cast(None, Month)
        self.Year = _cast(None, Year)
        self.Description = Description
    def factory(*args_, **kwargs_):
        if Ticket.subclass:
            return Ticket.subclass(*args_, **kwargs_)
        else:
            return Ticket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_Description(self, value):
        # validate type Description
        pass
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def validate_MonthType(self, value):
        # Validate type MonthType, a restriction on xs:string.
        pass
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def validate_YearType(self, value):
        # Validate type YearType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Ticket', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Ticket')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Ticket'):
        outfile.write(' Month=%s' % (quote_attrib(self.Month), ))
        outfile.write(' Year=%s' % (quote_attrib(self.Year), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Ticket'):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
    def hasContent_(self):
        if (
            self.Description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Ticket'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Month is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            showIndent(outfile, level)
            outfile.write('Month = "%s",\n' % (self.Month,))
        if self.Year is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            showIndent(outfile, level)
            outfile.write('Year = "%s",\n' % (self.Year,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Month')
        if value is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            self.Month = value
        value = attrs.get('Year')
        if value is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            self.Year = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            self.Description = Description_
            self.validate_Description(self.Description)    # validate type Description
# end class Ticket


class Claims(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Claim=None):
        if Claim is None:
            self.Claim = []
        else:
            self.Claim = Claim
    def factory(*args_, **kwargs_):
        if Claims.subclass:
            return Claims.subclass(*args_, **kwargs_)
        else:
            return Claims(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Claim(self): return self.Claim
    def set_Claim(self, Claim): self.Claim = Claim
    def add_Claim(self, value): self.Claim.append(value)
    def insert_Claim(self, index, value): self.Claim[index] = value
    def export(self, outfile, level, namespace_='', name_='Claims', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Claims')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Claims'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Claims'):
        for Claim_ in self.Claim:
            Claim_.export(outfile, level, namespace_, name_='Claim')
    def hasContent_(self):
        if (
            self.Claim
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Claims'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Claim=[\n')
        level += 1
        for Claim_ in self.Claim:
            showIndent(outfile, level)
            outfile.write('model_.Claim(\n')
            Claim_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Claim': 
            obj_ = Claim.factory()
            obj_.build(child_)
            self.Claim.append(obj_)
# end class Claims


class Claim(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Month=None, Year=None, Description=None, AtFault=None, WhatDamaged=None, InsurancePaidAmount=None):
        self.Month = _cast(None, Month)
        self.Year = _cast(None, Year)
        self.Description = Description
        self.AtFault = AtFault
        self.WhatDamaged = WhatDamaged
        self.InsurancePaidAmount = InsurancePaidAmount
    def factory(*args_, **kwargs_):
        if Claim.subclass:
            return Claim.subclass(*args_, **kwargs_)
        else:
            return Claim(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def validate_Description(self, value):
        # validate type Description
        pass
    def get_AtFault(self): return self.AtFault
    def set_AtFault(self, AtFault): self.AtFault = AtFault
    def validate_AtFault(self, value):
        # validate type AtFault
        pass
    def get_WhatDamaged(self): return self.WhatDamaged
    def set_WhatDamaged(self, WhatDamaged): self.WhatDamaged = WhatDamaged
    def validate_WhatDamaged(self, value):
        # Validate type WhatDamaged, a restriction on xs:string.
        pass
    def get_InsurancePaidAmount(self): return self.InsurancePaidAmount
    def set_InsurancePaidAmount(self, InsurancePaidAmount): self.InsurancePaidAmount = InsurancePaidAmount
    def get_Month(self): return self.Month
    def set_Month(self, Month): self.Month = Month
    def validate_MonthType(self, value):
        # Validate type MonthType, a restriction on xs:string.
        pass
    def get_Year(self): return self.Year
    def set_Year(self, Year): self.Year = Year
    def validate_YearType(self, value):
        # Validate type YearType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='Claim', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='Claim')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Claim'):
        outfile.write(' Month=%s' % (quote_attrib(self.Month), ))
        outfile.write(' Year=%s' % (quote_attrib(self.Year), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Claim'):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('<%sDescription>%s</%sDescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_))
        if self.AtFault is not None:
            showIndent(outfile, level)
            outfile.write('<%sAtFault>%s</%sAtFault>\n' % (namespace_, self.gds_format_string(quote_xml(self.AtFault).encode(ExternalEncoding), input_name='AtFault'), namespace_))
        if self.WhatDamaged is not None:
            showIndent(outfile, level)
            outfile.write('<%sWhatDamaged>%s</%sWhatDamaged>\n' % (namespace_, self.gds_format_string(quote_xml(self.WhatDamaged).encode(ExternalEncoding), input_name='WhatDamaged'), namespace_))
        if self.InsurancePaidAmount is not None:
            showIndent(outfile, level)
            outfile.write('<%sInsurancePaidAmount>%s</%sInsurancePaidAmount>\n' % (namespace_, self.gds_format_integer(self.InsurancePaidAmount, input_name='InsurancePaidAmount'), namespace_))
    def hasContent_(self):
        if (
            self.Description is not None or
            self.AtFault is not None or
            self.WhatDamaged is not None or
            self.InsurancePaidAmount is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Claim'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Month is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            showIndent(outfile, level)
            outfile.write('Month = "%s",\n' % (self.Month,))
        if self.Year is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            showIndent(outfile, level)
            outfile.write('Year = "%s",\n' % (self.Year,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.AtFault is not None:
            showIndent(outfile, level)
            outfile.write('AtFault=%s,\n' % quote_python(self.AtFault).encode(ExternalEncoding))
        if self.WhatDamaged is not None:
            showIndent(outfile, level)
            outfile.write('WhatDamaged=%s,\n' % quote_python(self.WhatDamaged).encode(ExternalEncoding))
        if self.InsurancePaidAmount is not None:
            showIndent(outfile, level)
            outfile.write('InsurancePaidAmount=%d,\n' % self.InsurancePaidAmount)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Month')
        if value is not None and 'Month' not in already_processed:
            already_processed.append('Month')
            self.Month = value
        value = attrs.get('Year')
        if value is not None and 'Year' not in already_processed:
            already_processed.append('Year')
            self.Year = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            self.Description = Description_
            self.validate_Description(self.Description)    # validate type Description
        elif nodeName_ == 'AtFault':
            AtFault_ = child_.text
            self.AtFault = AtFault_
            self.validate_AtFault(self.AtFault)    # validate type AtFault
        elif nodeName_ == 'WhatDamaged':
            WhatDamaged_ = child_.text
            self.WhatDamaged = WhatDamaged_
            self.validate_WhatDamaged(self.WhatDamaged)    # validate type WhatDamaged
        elif nodeName_ == 'InsurancePaidAmount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.InsurancePaidAmount = ival_
# end class Claim


class HomeLeadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PersonInfo=None, PropertyAddress=None, PropertyProfile=None, PropertyFeatures=None, Claims=None):
        self.PersonInfo = PersonInfo
        self.PropertyAddress = PropertyAddress
        self.PropertyProfile = PropertyProfile
        self.PropertyFeatures = PropertyFeatures
        self.Claims = Claims
    def factory(*args_, **kwargs_):
        if HomeLeadType.subclass:
            return HomeLeadType.subclass(*args_, **kwargs_)
        else:
            return HomeLeadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonInfo(self): return self.PersonInfo
    def set_PersonInfo(self, PersonInfo): self.PersonInfo = PersonInfo
    def get_PropertyAddress(self): return self.PropertyAddress
    def set_PropertyAddress(self, PropertyAddress): self.PropertyAddress = PropertyAddress
    def get_PropertyProfile(self): return self.PropertyProfile
    def set_PropertyProfile(self, PropertyProfile): self.PropertyProfile = PropertyProfile
    def get_PropertyFeatures(self): return self.PropertyFeatures
    def set_PropertyFeatures(self, PropertyFeatures): self.PropertyFeatures = PropertyFeatures
    def get_Claims(self): return self.Claims
    def set_Claims(self, Claims): self.Claims = Claims
    def export(self, outfile, level, namespace_='', name_='HomeLeadType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HomeLeadType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HomeLeadType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HomeLeadType'):
        if self.PersonInfo:
            self.PersonInfo.export(outfile, level, namespace_, name_='PersonInfo', )
        if self.PropertyAddress:
            self.PropertyAddress.export(outfile, level, namespace_, name_='PropertyAddress', )
        if self.PropertyProfile:
            self.PropertyProfile.export(outfile, level, namespace_, name_='PropertyProfile', )
        if self.PropertyFeatures:
            self.PropertyFeatures.export(outfile, level, namespace_, name_='PropertyFeatures', )
        if self.Claims:
            self.Claims.export(outfile, level, namespace_, name_='Claims')
    def hasContent_(self):
        if (
            self.PersonInfo is not None or
            self.PropertyAddress is not None or
            self.PropertyProfile is not None or
            self.PropertyFeatures is not None or
            self.Claims is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HomeLeadType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PersonInfo is not None:
            showIndent(outfile, level)
            outfile.write('PersonInfo=model_.PersonInfo(\n')
            self.PersonInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertyAddress is not None:
            showIndent(outfile, level)
            outfile.write('PropertyAddress=model_.PropertyAddress(\n')
            self.PropertyAddress.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertyProfile is not None:
            showIndent(outfile, level)
            outfile.write('PropertyProfile=model_.PropertyProfile(\n')
            self.PropertyProfile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PropertyFeatures is not None:
            showIndent(outfile, level)
            outfile.write('PropertyFeatures=model_.PropertyFeatures(\n')
            self.PropertyFeatures.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Claims is not None:
            showIndent(outfile, level)
            outfile.write('Claims=model_.Claims(\n')
            self.Claims.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PersonInfo': 
            obj_ = PersonInfo.factory()
            obj_.build(child_)
            self.set_PersonInfo(obj_)
        elif nodeName_ == 'PropertyAddress': 
            obj_ = PropertyAddress.factory()
            obj_.build(child_)
            self.set_PropertyAddress(obj_)
        elif nodeName_ == 'PropertyProfile': 
            obj_ = PropertyProfile.factory()
            obj_.build(child_)
            self.set_PropertyProfile(obj_)
        elif nodeName_ == 'PropertyFeatures': 
            obj_ = PropertyFeatures.factory()
            obj_.build(child_)
            self.set_PropertyFeatures(obj_)
        elif nodeName_ == 'Claims': 
            obj_ = Claims.factory()
            obj_.build(child_)
            self.set_Claims(obj_)
# end class HomeLeadType


class PersonInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Gender=None, FirstName=None, LastName=None, BirthDate=None, CreditRating=None):
        self.Gender = _cast(None, Gender)
        self.FirstName = FirstName
        self.LastName = LastName
        self.BirthDate = BirthDate
        self.CreditRating = CreditRating
    def factory(*args_, **kwargs_):
        if PersonInfo.subclass:
            return PersonInfo.subclass(*args_, **kwargs_)
        else:
            return PersonInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FirstName(self): return self.FirstName
    def set_FirstName(self, FirstName): self.FirstName = FirstName
    def get_LastName(self): return self.LastName
    def set_LastName(self, LastName): self.LastName = LastName
    def get_BirthDate(self): return self.BirthDate
    def set_BirthDate(self, BirthDate): self.BirthDate = BirthDate
    def get_CreditRating(self): return self.CreditRating
    def set_CreditRating(self, CreditRating): self.CreditRating = CreditRating
    def validate_CreditRating(self, value):
        # validate type CreditRating
        pass
    def get_Gender(self): return self.Gender
    def set_Gender(self, Gender): self.Gender = Gender
    def validate_GenderType(self, value):
        # Validate type GenderType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PersonInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PersonInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PersonInfo'):
        outfile.write(' Gender=%s' % (quote_attrib(self.Gender), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PersonInfo'):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('<%sFirstName>%s</%sFirstName>\n' % (namespace_, self.gds_format_string(quote_xml(self.FirstName).encode(ExternalEncoding), input_name='FirstName'), namespace_))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('<%sLastName>%s</%sLastName>\n' % (namespace_, self.gds_format_string(quote_xml(self.LastName).encode(ExternalEncoding), input_name='LastName'), namespace_))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('<%sBirthDate>%s</%sBirthDate>\n' % (namespace_, self.gds_format_string(quote_xml(self.BirthDate).encode(ExternalEncoding), input_name='BirthDate'), namespace_))
        if self.CreditRating is not None:
            showIndent(outfile, level)
            outfile.write('<%sCreditRating>%s</%sCreditRating>\n' % (namespace_, self.gds_format_string(quote_xml(self.CreditRating).encode(ExternalEncoding), input_name='CreditRating'), namespace_))
    def hasContent_(self):
        if (
            self.FirstName is not None or
            self.LastName is not None or
            self.BirthDate is not None or
            self.CreditRating is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PersonInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Gender is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            showIndent(outfile, level)
            outfile.write('Gender = "%s",\n' % (self.Gender,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FirstName is not None:
            showIndent(outfile, level)
            outfile.write('FirstName=%s,\n' % quote_python(self.FirstName).encode(ExternalEncoding))
        if self.LastName is not None:
            showIndent(outfile, level)
            outfile.write('LastName=%s,\n' % quote_python(self.LastName).encode(ExternalEncoding))
        if self.BirthDate is not None:
            showIndent(outfile, level)
            outfile.write('BirthDate=%s,\n' % quote_python(self.BirthDate).encode(ExternalEncoding))
        if self.CreditRating is not None:
            showIndent(outfile, level)
            outfile.write('CreditRating=%s,\n' % quote_python(self.CreditRating).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Gender')
        if value is not None and 'Gender' not in already_processed:
            already_processed.append('Gender')
            self.Gender = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'FirstName':
            FirstName_ = child_.text
            self.FirstName = FirstName_
        elif nodeName_ == 'LastName':
            LastName_ = child_.text
            self.LastName = LastName_
        elif nodeName_ == 'BirthDate':
            BirthDate_ = child_.text
            self.BirthDate = BirthDate_
        elif nodeName_ == 'CreditRating':
            CreditRating_ = child_.text
            self.CreditRating = CreditRating_
            self.validate_CreditRating(self.CreditRating)    # validate type CreditRating
# end class PersonInfo


class PropertyAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PropAddress=None, PropCity=None, PropState=None, PropZIPCode=None):
        self.PropAddress = PropAddress
        self.PropCity = PropCity
        self.PropState = PropState
        self.PropZIPCode = PropZIPCode
    def factory(*args_, **kwargs_):
        if PropertyAddress.subclass:
            return PropertyAddress.subclass(*args_, **kwargs_)
        else:
            return PropertyAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropAddress(self): return self.PropAddress
    def set_PropAddress(self, PropAddress): self.PropAddress = PropAddress
    def get_PropCity(self): return self.PropCity
    def set_PropCity(self, PropCity): self.PropCity = PropCity
    def get_PropState(self): return self.PropState
    def set_PropState(self, PropState): self.PropState = PropState
    def validate_PropState(self, value):
        # validate type PropState
        pass
    def get_PropZIPCode(self): return self.PropZIPCode
    def set_PropZIPCode(self, PropZIPCode): self.PropZIPCode = PropZIPCode
    def validate_PropZIPCode(self, value):
        # validate type PropZIPCode
        pass
    def export(self, outfile, level, namespace_='', name_='PropertyAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PropertyAddress')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyAddress'):
        if self.PropAddress is not None:
            showIndent(outfile, level)
            outfile.write('<%sPropAddress>%s</%sPropAddress>\n' % (namespace_, self.gds_format_string(quote_xml(self.PropAddress).encode(ExternalEncoding), input_name='PropAddress'), namespace_))
        if self.PropCity is not None:
            showIndent(outfile, level)
            outfile.write('<%sPropCity>%s</%sPropCity>\n' % (namespace_, self.gds_format_string(quote_xml(self.PropCity).encode(ExternalEncoding), input_name='PropCity'), namespace_))
        if self.PropState is not None:
            showIndent(outfile, level)
            outfile.write('<%sPropState>%s</%sPropState>\n' % (namespace_, self.gds_format_string(quote_xml(self.PropState).encode(ExternalEncoding), input_name='PropState'), namespace_))
        if self.PropZIPCode is not None:
            showIndent(outfile, level)
            outfile.write('<%sPropZIPCode>%s</%sPropZIPCode>\n' % (namespace_, self.gds_format_string(quote_xml(self.PropZIPCode).encode(ExternalEncoding), input_name='PropZIPCode'), namespace_))
    def hasContent_(self):
        if (
            self.PropAddress is not None or
            self.PropCity is not None or
            self.PropState is not None or
            self.PropZIPCode is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PropAddress is not None:
            showIndent(outfile, level)
            outfile.write('PropAddress=%s,\n' % quote_python(self.PropAddress).encode(ExternalEncoding))
        if self.PropCity is not None:
            showIndent(outfile, level)
            outfile.write('PropCity=%s,\n' % quote_python(self.PropCity).encode(ExternalEncoding))
        if self.PropState is not None:
            showIndent(outfile, level)
            outfile.write('PropState=%s,\n' % quote_python(self.PropState).encode(ExternalEncoding))
        if self.PropZIPCode is not None:
            showIndent(outfile, level)
            outfile.write('PropZIPCode=%s,\n' % quote_python(self.PropZIPCode).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PropAddress':
            PropAddress_ = child_.text
            self.PropAddress = PropAddress_
        elif nodeName_ == 'PropCity':
            PropCity_ = child_.text
            self.PropCity = PropCity_
        elif nodeName_ == 'PropState':
            PropState_ = child_.text
            self.PropState = PropState_
            self.validate_PropState(self.PropState)    # validate type PropState
        elif nodeName_ == 'PropZIPCode':
            PropZIPCode_ = child_.text
            self.PropZIPCode = PropZIPCode_
            self.validate_PropZIPCode(self.PropZIPCode)    # validate type PropZIPCode
# end class PropertyAddress


class PropertyProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, BusinessOrFarmingConducted=None, PropertyType=None, NumberUnits=None, DangerousDog=None, ConstructionDetails=None):
        self.BusinessOrFarmingConducted = _cast(None, BusinessOrFarmingConducted)
        self.PropertyType = PropertyType
        self.NumberUnits = NumberUnits
        self.DangerousDog = DangerousDog
        self.ConstructionDetails = ConstructionDetails
    def factory(*args_, **kwargs_):
        if PropertyProfile.subclass:
            return PropertyProfile.subclass(*args_, **kwargs_)
        else:
            return PropertyProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyType(self): return self.PropertyType
    def set_PropertyType(self, PropertyType): self.PropertyType = PropertyType
    def validate_PropertyType(self, value):
        # validate type PropertyType
        pass
    def get_NumberUnits(self): return self.NumberUnits
    def set_NumberUnits(self, NumberUnits): self.NumberUnits = NumberUnits
    def validate_NumberUnits(self, value):
        # validate type NumberUnits
        pass
    def get_DangerousDog(self): return self.DangerousDog
    def set_DangerousDog(self, DangerousDog): self.DangerousDog = DangerousDog
    def validate_DangerousDog(self, value):
        # validate type DangerousDog
        pass
    def get_ConstructionDetails(self): return self.ConstructionDetails
    def set_ConstructionDetails(self, ConstructionDetails): self.ConstructionDetails = ConstructionDetails
    def get_BusinessOrFarmingConducted(self): return self.BusinessOrFarmingConducted
    def set_BusinessOrFarmingConducted(self, BusinessOrFarmingConducted): self.BusinessOrFarmingConducted = BusinessOrFarmingConducted
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PropertyProfile', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PropertyProfile')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyProfile'):
        outfile.write(' BusinessOrFarmingConducted=%s' % (quote_attrib(self.BusinessOrFarmingConducted), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyProfile'):
        if self.PropertyType is not None:
            showIndent(outfile, level)
            outfile.write('<%sPropertyType>%s</%sPropertyType>\n' % (namespace_, self.gds_format_string(quote_xml(self.PropertyType).encode(ExternalEncoding), input_name='PropertyType'), namespace_))
        if self.NumberUnits is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumberUnits>%s</%sNumberUnits>\n' % (namespace_, self.gds_format_integer(self.NumberUnits, input_name='NumberUnits'), namespace_))
        if self.DangerousDog is not None:
            showIndent(outfile, level)
            outfile.write('<%sDangerousDog>%s</%sDangerousDog>\n' % (namespace_, self.gds_format_string(quote_xml(self.DangerousDog).encode(ExternalEncoding), input_name='DangerousDog'), namespace_))
        if self.ConstructionDetails:
            self.ConstructionDetails.export(outfile, level, namespace_, name_='ConstructionDetails', )
    def hasContent_(self):
        if (
            self.PropertyType is not None or
            self.NumberUnits is not None or
            self.DangerousDog is not None or
            self.ConstructionDetails is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyProfile'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.BusinessOrFarmingConducted is not None and 'BusinessOrFarmingConducted' not in already_processed:
            already_processed.append('BusinessOrFarmingConducted')
            showIndent(outfile, level)
            outfile.write('BusinessOrFarmingConducted = "%s",\n' % (self.BusinessOrFarmingConducted,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PropertyType is not None:
            showIndent(outfile, level)
            outfile.write('PropertyType=%s,\n' % quote_python(self.PropertyType).encode(ExternalEncoding))
        if self.NumberUnits is not None:
            showIndent(outfile, level)
            outfile.write('NumberUnits=%d,\n' % self.NumberUnits)
        if self.DangerousDog is not None:
            showIndent(outfile, level)
            outfile.write('DangerousDog=%s,\n' % quote_python(self.DangerousDog).encode(ExternalEncoding))
        if self.ConstructionDetails is not None:
            showIndent(outfile, level)
            outfile.write('ConstructionDetails=model_.ConstructionDetails(\n')
            self.ConstructionDetails.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('BusinessOrFarmingConducted')
        if value is not None and 'BusinessOrFarmingConducted' not in already_processed:
            already_processed.append('BusinessOrFarmingConducted')
            self.BusinessOrFarmingConducted = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'PropertyType':
            PropertyType_ = child_.text
            self.PropertyType = PropertyType_
            self.validate_PropertyType(self.PropertyType)    # validate type PropertyType
        elif nodeName_ == 'NumberUnits':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            self.NumberUnits = ival_
            self.validate_NumberUnits(self.NumberUnits)    # validate type NumberUnits
        elif nodeName_ == 'DangerousDog':
            DangerousDog_ = child_.text
            self.DangerousDog = DangerousDog_
            self.validate_DangerousDog(self.DangerousDog)    # validate type DangerousDog
        elif nodeName_ == 'ConstructionDetails': 
            obj_ = ConstructionDetails.factory()
            obj_.build(child_)
            self.set_ConstructionDetails(obj_)
# end class PropertyProfile


class ConstructionDetails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExteriorWalls=None, Stories=None, Roof=None, Basement=None, BuiltYear=None, LivableSquareFootage=None, Bedrooms=None, Bathrooms=None, Garage=None, HeatingType=None, SecuritySystem=None, FireAlarm=None):
        self.ExteriorWalls = _cast(None, ExteriorWalls)
        self.Stories = _cast(None, Stories)
        self.Roof = _cast(None, Roof)
        self.Basement = _cast(None, Basement)
        self.BuiltYear = BuiltYear
        self.LivableSquareFootage = LivableSquareFootage
        self.Bedrooms = Bedrooms
        self.Bathrooms = Bathrooms
        self.Garage = Garage
        self.HeatingType = HeatingType
        self.SecuritySystem = SecuritySystem
        self.FireAlarm = FireAlarm
    def factory(*args_, **kwargs_):
        if ConstructionDetails.subclass:
            return ConstructionDetails.subclass(*args_, **kwargs_)
        else:
            return ConstructionDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BuiltYear(self): return self.BuiltYear
    def set_BuiltYear(self, BuiltYear): self.BuiltYear = BuiltYear
    def validate_BuiltYear(self, value):
        # validate type BuiltYear
        pass
    def get_LivableSquareFootage(self): return self.LivableSquareFootage
    def set_LivableSquareFootage(self, LivableSquareFootage): self.LivableSquareFootage = LivableSquareFootage
    def validate_LivableSquareFootage(self, value):
        # validate type LivableSquareFootage
        pass
    def get_Bedrooms(self): return self.Bedrooms
    def set_Bedrooms(self, Bedrooms): self.Bedrooms = Bedrooms
    def validate_Bedrooms(self, value):
        # validate type Bedrooms
        pass
    def get_Bathrooms(self): return self.Bathrooms
    def set_Bathrooms(self, Bathrooms): self.Bathrooms = Bathrooms
    def validate_Bathrooms(self, value):
        # validate type Bathrooms
        pass
    def get_Garage(self): return self.Garage
    def set_Garage(self, Garage): self.Garage = Garage
    def validate_Garage(self, value):
        # validate type Garage
        pass
    def get_HeatingType(self): return self.HeatingType
    def set_HeatingType(self, HeatingType): self.HeatingType = HeatingType
    def validate_HeatingType(self, value):
        # Validate type HeatingType, a restriction on xs:string.
        pass
    def get_SecuritySystem(self): return self.SecuritySystem
    def set_SecuritySystem(self, SecuritySystem): self.SecuritySystem = SecuritySystem
    def validate_SecuritySystem(self, value):
        # validate type SecuritySystem
        pass
    def get_FireAlarm(self): return self.FireAlarm
    def set_FireAlarm(self, FireAlarm): self.FireAlarm = FireAlarm
    def validate_FireAlarm(self, value):
        # validate type FireAlarm
        pass
    def get_ExteriorWalls(self): return self.ExteriorWalls
    def set_ExteriorWalls(self, ExteriorWalls): self.ExteriorWalls = ExteriorWalls
    def validate_ExteriorWallsType(self, value):
        # Validate type ExteriorWallsType, a restriction on xs:string.
        pass
    def get_Stories(self): return self.Stories
    def set_Stories(self, Stories): self.Stories = Stories
    def validate_StoriesType(self, value):
        # Validate type StoriesType, a restriction on xs:string.
        pass
    def get_Roof(self): return self.Roof
    def set_Roof(self, Roof): self.Roof = Roof
    def validate_RoofType(self, value):
        # Validate type RoofType, a restriction on xs:string.
        pass
    def get_Basement(self): return self.Basement
    def set_Basement(self, Basement): self.Basement = Basement
    def validate_BasementType(self, value):
        # Validate type BasementType, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='ConstructionDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ConstructionDetails')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConstructionDetails'):
        outfile.write(' ExteriorWalls=%s' % (quote_attrib(self.ExteriorWalls), ))
        outfile.write(' Stories=%s' % (quote_attrib(self.Stories), ))
        outfile.write(' Roof=%s' % (quote_attrib(self.Roof), ))
        outfile.write(' Basement=%s' % (quote_attrib(self.Basement), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConstructionDetails'):
        if self.BuiltYear is not None:
            showIndent(outfile, level)
            outfile.write('<%sBuiltYear>%s</%sBuiltYear>\n' % (namespace_, self.gds_format_string(quote_xml(self.BuiltYear).encode(ExternalEncoding), input_name='BuiltYear'), namespace_))
        if self.LivableSquareFootage is not None:
            showIndent(outfile, level)
            outfile.write('<%sLivableSquareFootage>%s</%sLivableSquareFootage>\n' % (namespace_, self.gds_format_string(quote_xml(self.LivableSquareFootage).encode(ExternalEncoding), input_name='LivableSquareFootage'), namespace_))
        if self.Bedrooms is not None:
            showIndent(outfile, level)
            outfile.write('<%sBedrooms>%s</%sBedrooms>\n' % (namespace_, self.gds_format_string(quote_xml(self.Bedrooms).encode(ExternalEncoding), input_name='Bedrooms'), namespace_))
        if self.Bathrooms is not None:
            showIndent(outfile, level)
            outfile.write('<%sBathrooms>%s</%sBathrooms>\n' % (namespace_, self.gds_format_string(quote_xml(self.Bathrooms).encode(ExternalEncoding), input_name='Bathrooms'), namespace_))
        if self.Garage is not None:
            showIndent(outfile, level)
            outfile.write('<%sGarage>%s</%sGarage>\n' % (namespace_, self.gds_format_string(quote_xml(self.Garage).encode(ExternalEncoding), input_name='Garage'), namespace_))
        if self.HeatingType is not None:
            showIndent(outfile, level)
            outfile.write('<%sHeatingType>%s</%sHeatingType>\n' % (namespace_, self.gds_format_string(quote_xml(self.HeatingType).encode(ExternalEncoding), input_name='HeatingType'), namespace_))
        if self.SecuritySystem is not None:
            showIndent(outfile, level)
            outfile.write('<%sSecuritySystem>%s</%sSecuritySystem>\n' % (namespace_, self.gds_format_string(quote_xml(self.SecuritySystem).encode(ExternalEncoding), input_name='SecuritySystem'), namespace_))
        if self.FireAlarm is not None:
            showIndent(outfile, level)
            outfile.write('<%sFireAlarm>%s</%sFireAlarm>\n' % (namespace_, self.gds_format_string(quote_xml(self.FireAlarm).encode(ExternalEncoding), input_name='FireAlarm'), namespace_))
    def hasContent_(self):
        if (
            self.BuiltYear is not None or
            self.LivableSquareFootage is not None or
            self.Bedrooms is not None or
            self.Bathrooms is not None or
            self.Garage is not None or
            self.HeatingType is not None or
            self.SecuritySystem is not None or
            self.FireAlarm is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConstructionDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ExteriorWalls is not None and 'ExteriorWalls' not in already_processed:
            already_processed.append('ExteriorWalls')
            showIndent(outfile, level)
            outfile.write('ExteriorWalls = "%s",\n' % (self.ExteriorWalls,))
        if self.Stories is not None and 'Stories' not in already_processed:
            already_processed.append('Stories')
            showIndent(outfile, level)
            outfile.write('Stories = "%s",\n' % (self.Stories,))
        if self.Roof is not None and 'Roof' not in already_processed:
            already_processed.append('Roof')
            showIndent(outfile, level)
            outfile.write('Roof = "%s",\n' % (self.Roof,))
        if self.Basement is not None and 'Basement' not in already_processed:
            already_processed.append('Basement')
            showIndent(outfile, level)
            outfile.write('Basement = "%s",\n' % (self.Basement,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.BuiltYear is not None:
            showIndent(outfile, level)
            outfile.write('BuiltYear=%s,\n' % quote_python(self.BuiltYear).encode(ExternalEncoding))
        if self.LivableSquareFootage is not None:
            showIndent(outfile, level)
            outfile.write('LivableSquareFootage=%s,\n' % quote_python(self.LivableSquareFootage).encode(ExternalEncoding))
        if self.Bedrooms is not None:
            showIndent(outfile, level)
            outfile.write('Bedrooms=%s,\n' % quote_python(self.Bedrooms).encode(ExternalEncoding))
        if self.Bathrooms is not None:
            showIndent(outfile, level)
            outfile.write('Bathrooms=%s,\n' % quote_python(self.Bathrooms).encode(ExternalEncoding))
        if self.Garage is not None:
            showIndent(outfile, level)
            outfile.write('Garage=%s,\n' % quote_python(self.Garage).encode(ExternalEncoding))
        if self.HeatingType is not None:
            showIndent(outfile, level)
            outfile.write('HeatingType=%s,\n' % quote_python(self.HeatingType).encode(ExternalEncoding))
        if self.SecuritySystem is not None:
            showIndent(outfile, level)
            outfile.write('SecuritySystem=%s,\n' % quote_python(self.SecuritySystem).encode(ExternalEncoding))
        if self.FireAlarm is not None:
            showIndent(outfile, level)
            outfile.write('FireAlarm=%s,\n' % quote_python(self.FireAlarm).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('ExteriorWalls')
        if value is not None and 'ExteriorWalls' not in already_processed:
            already_processed.append('ExteriorWalls')
            self.ExteriorWalls = value
        value = attrs.get('Stories')
        if value is not None and 'Stories' not in already_processed:
            already_processed.append('Stories')
            self.Stories = value
        value = attrs.get('Roof')
        if value is not None and 'Roof' not in already_processed:
            already_processed.append('Roof')
            self.Roof = value
        value = attrs.get('Basement')
        if value is not None and 'Basement' not in already_processed:
            already_processed.append('Basement')
            self.Basement = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'BuiltYear':
            BuiltYear_ = child_.text
            self.BuiltYear = BuiltYear_
            self.validate_BuiltYear(self.BuiltYear)    # validate type BuiltYear
        elif nodeName_ == 'LivableSquareFootage':
            LivableSquareFootage_ = child_.text
            self.LivableSquareFootage = LivableSquareFootage_
            self.validate_LivableSquareFootage(self.LivableSquareFootage)    # validate type LivableSquareFootage
        elif nodeName_ == 'Bedrooms':
            Bedrooms_ = child_.text
            self.Bedrooms = Bedrooms_
            self.validate_Bedrooms(self.Bedrooms)    # validate type Bedrooms
        elif nodeName_ == 'Bathrooms':
            Bathrooms_ = child_.text
            self.Bathrooms = Bathrooms_
            self.validate_Bathrooms(self.Bathrooms)    # validate type Bathrooms
        elif nodeName_ == 'Garage':
            Garage_ = child_.text
            self.Garage = Garage_
            self.validate_Garage(self.Garage)    # validate type Garage
        elif nodeName_ == 'HeatingType':
            HeatingType_ = child_.text
            self.HeatingType = HeatingType_
            self.validate_HeatingType(self.HeatingType)    # validate type HeatingType
        elif nodeName_ == 'SecuritySystem':
            SecuritySystem_ = child_.text
            self.SecuritySystem = SecuritySystem_
            self.validate_SecuritySystem(self.SecuritySystem)    # validate type SecuritySystem
        elif nodeName_ == 'FireAlarm':
            FireAlarm_ = child_.text
            self.FireAlarm = FireAlarm_
            self.validate_FireAlarm(self.FireAlarm)    # validate type FireAlarm
# end class ConstructionDetails


class PropertyFeatures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Trampoline=None, HotTub=None, SumpPump=None, Deck=None, FireExtinguisher=None, CentralAirConditioning=None, DeadBolt=None, SmokeDetector=None, Sauna=None, Fireplace=None, SwimmingPool=None, WoodburningStove=None, valueOf_=None):
        self.Trampoline = _cast(None, Trampoline)
        self.HotTub = _cast(None, HotTub)
        self.SumpPump = _cast(None, SumpPump)
        self.Deck = _cast(None, Deck)
        self.FireExtinguisher = _cast(None, FireExtinguisher)
        self.CentralAirConditioning = _cast(None, CentralAirConditioning)
        self.DeadBolt = _cast(None, DeadBolt)
        self.SmokeDetector = _cast(None, SmokeDetector)
        self.Sauna = _cast(None, Sauna)
        self.Fireplace = _cast(None, Fireplace)
        self.SwimmingPool = _cast(None, SwimmingPool)
        self.WoodburningStove = _cast(None, WoodburningStove)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PropertyFeatures.subclass:
            return PropertyFeatures.subclass(*args_, **kwargs_)
        else:
            return PropertyFeatures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Trampoline(self): return self.Trampoline
    def set_Trampoline(self, Trampoline): self.Trampoline = Trampoline
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def get_HotTub(self): return self.HotTub
    def set_HotTub(self, HotTub): self.HotTub = HotTub
    def get_SumpPump(self): return self.SumpPump
    def set_SumpPump(self, SumpPump): self.SumpPump = SumpPump
    def get_Deck(self): return self.Deck
    def set_Deck(self, Deck): self.Deck = Deck
    def get_FireExtinguisher(self): return self.FireExtinguisher
    def set_FireExtinguisher(self, FireExtinguisher): self.FireExtinguisher = FireExtinguisher
    def get_CentralAirConditioning(self): return self.CentralAirConditioning
    def set_CentralAirConditioning(self, CentralAirConditioning): self.CentralAirConditioning = CentralAirConditioning
    def get_DeadBolt(self): return self.DeadBolt
    def set_DeadBolt(self, DeadBolt): self.DeadBolt = DeadBolt
    def get_SmokeDetector(self): return self.SmokeDetector
    def set_SmokeDetector(self, SmokeDetector): self.SmokeDetector = SmokeDetector
    def get_Sauna(self): return self.Sauna
    def set_Sauna(self, Sauna): self.Sauna = Sauna
    def get_Fireplace(self): return self.Fireplace
    def set_Fireplace(self, Fireplace): self.Fireplace = Fireplace
    def get_SwimmingPool(self): return self.SwimmingPool
    def set_SwimmingPool(self, SwimmingPool): self.SwimmingPool = SwimmingPool
    def get_WoodburningStove(self): return self.WoodburningStove
    def set_WoodburningStove(self, WoodburningStove): self.WoodburningStove = WoodburningStove
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='PropertyFeatures', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PropertyFeatures')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyFeatures'):
        outfile.write(' Trampoline=%s' % (quote_attrib(self.Trampoline), ))
        outfile.write(' HotTub=%s' % (quote_attrib(self.HotTub), ))
        outfile.write(' SumpPump=%s' % (quote_attrib(self.SumpPump), ))
        outfile.write(' Deck=%s' % (quote_attrib(self.Deck), ))
        outfile.write(' FireExtinguisher=%s' % (quote_attrib(self.FireExtinguisher), ))
        outfile.write(' CentralAirConditioning=%s' % (quote_attrib(self.CentralAirConditioning), ))
        outfile.write(' DeadBolt=%s' % (quote_attrib(self.DeadBolt), ))
        outfile.write(' SmokeDetector=%s' % (quote_attrib(self.SmokeDetector), ))
        outfile.write(' Sauna=%s' % (quote_attrib(self.Sauna), ))
        outfile.write(' Fireplace=%s' % (quote_attrib(self.Fireplace), ))
        outfile.write(' SwimmingPool=%s' % (quote_attrib(self.SwimmingPool), ))
        outfile.write(' WoodburningStove=%s' % (quote_attrib(self.WoodburningStove), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyFeatures'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PropertyFeatures'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Trampoline is not None and 'Trampoline' not in already_processed:
            already_processed.append('Trampoline')
            showIndent(outfile, level)
            outfile.write('Trampoline = "%s",\n' % (self.Trampoline,))
        if self.HotTub is not None and 'HotTub' not in already_processed:
            already_processed.append('HotTub')
            showIndent(outfile, level)
            outfile.write('HotTub = "%s",\n' % (self.HotTub,))
        if self.SumpPump is not None and 'SumpPump' not in already_processed:
            already_processed.append('SumpPump')
            showIndent(outfile, level)
            outfile.write('SumpPump = "%s",\n' % (self.SumpPump,))
        if self.Deck is not None and 'Deck' not in already_processed:
            already_processed.append('Deck')
            showIndent(outfile, level)
            outfile.write('Deck = "%s",\n' % (self.Deck,))
        if self.FireExtinguisher is not None and 'FireExtinguisher' not in already_processed:
            already_processed.append('FireExtinguisher')
            showIndent(outfile, level)
            outfile.write('FireExtinguisher = "%s",\n' % (self.FireExtinguisher,))
        if self.CentralAirConditioning is not None and 'CentralAirConditioning' not in already_processed:
            already_processed.append('CentralAirConditioning')
            showIndent(outfile, level)
            outfile.write('CentralAirConditioning = "%s",\n' % (self.CentralAirConditioning,))
        if self.DeadBolt is not None and 'DeadBolt' not in already_processed:
            already_processed.append('DeadBolt')
            showIndent(outfile, level)
            outfile.write('DeadBolt = "%s",\n' % (self.DeadBolt,))
        if self.SmokeDetector is not None and 'SmokeDetector' not in already_processed:
            already_processed.append('SmokeDetector')
            showIndent(outfile, level)
            outfile.write('SmokeDetector = "%s",\n' % (self.SmokeDetector,))
        if self.Sauna is not None and 'Sauna' not in already_processed:
            already_processed.append('Sauna')
            showIndent(outfile, level)
            outfile.write('Sauna = "%s",\n' % (self.Sauna,))
        if self.Fireplace is not None and 'Fireplace' not in already_processed:
            already_processed.append('Fireplace')
            showIndent(outfile, level)
            outfile.write('Fireplace = "%s",\n' % (self.Fireplace,))
        if self.SwimmingPool is not None and 'SwimmingPool' not in already_processed:
            already_processed.append('SwimmingPool')
            showIndent(outfile, level)
            outfile.write('SwimmingPool = "%s",\n' % (self.SwimmingPool,))
        if self.WoodburningStove is not None and 'WoodburningStove' not in already_processed:
            already_processed.append('WoodburningStove')
            showIndent(outfile, level)
            outfile.write('WoodburningStove = "%s",\n' % (self.WoodburningStove,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Trampoline')
        if value is not None and 'Trampoline' not in already_processed:
            already_processed.append('Trampoline')
            self.Trampoline = value
        value = attrs.get('HotTub')
        if value is not None and 'HotTub' not in already_processed:
            already_processed.append('HotTub')
            self.HotTub = value
        value = attrs.get('SumpPump')
        if value is not None and 'SumpPump' not in already_processed:
            already_processed.append('SumpPump')
            self.SumpPump = value
        value = attrs.get('Deck')
        if value is not None and 'Deck' not in already_processed:
            already_processed.append('Deck')
            self.Deck = value
        value = attrs.get('FireExtinguisher')
        if value is not None and 'FireExtinguisher' not in already_processed:
            already_processed.append('FireExtinguisher')
            self.FireExtinguisher = value
        value = attrs.get('CentralAirConditioning')
        if value is not None and 'CentralAirConditioning' not in already_processed:
            already_processed.append('CentralAirConditioning')
            self.CentralAirConditioning = value
        value = attrs.get('DeadBolt')
        if value is not None and 'DeadBolt' not in already_processed:
            already_processed.append('DeadBolt')
            self.DeadBolt = value
        value = attrs.get('SmokeDetector')
        if value is not None and 'SmokeDetector' not in already_processed:
            already_processed.append('SmokeDetector')
            self.SmokeDetector = value
        value = attrs.get('Sauna')
        if value is not None and 'Sauna' not in already_processed:
            already_processed.append('Sauna')
            self.Sauna = value
        value = attrs.get('Fireplace')
        if value is not None and 'Fireplace' not in already_processed:
            already_processed.append('Fireplace')
            self.Fireplace = value
        value = attrs.get('SwimmingPool')
        if value is not None and 'SwimmingPool' not in already_processed:
            already_processed.append('SwimmingPool')
            self.SwimmingPool = value
        value = attrs.get('WoodburningStove')
        if value is not None and 'WoodburningStove' not in already_processed:
            already_processed.append('WoodburningStove')
            self.WoodburningStove = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class PropertyFeatures


class PhoneNumberType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Number=None, Extension=None):
        self.Type = _cast(None, Type)
        self.Number = Number
        self.Extension = Extension
    def factory(*args_, **kwargs_):
        if PhoneNumberType.subclass:
            return PhoneNumberType.subclass(*args_, **kwargs_)
        else:
            return PhoneNumberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Number(self): return self.Number
    def set_Number(self, Number): self.Number = Number
    def validate_Number(self, value):
        # validate type Number
        pass
    def get_Extension(self): return self.Extension
    def set_Extension(self, Extension): self.Extension = Extension
    def validate_Extension(self, value):
        # validate type Extension
        pass
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def validate_PhoneTypeValue(self, value):
        # Validate type PhoneTypeValue, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='', name_='PhoneNumberType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PhoneNumberType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhoneNumberType'):
        outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PhoneNumberType'):
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('<%sNumber>%s</%sNumber>\n' % (namespace_, self.gds_format_string(quote_xml(self.Number).encode(ExternalEncoding), input_name='Number'), namespace_))
        if self.Extension is not None:
            showIndent(outfile, level)
            outfile.write('<%sExtension>%s</%sExtension>\n' % (namespace_, self.gds_format_string(quote_xml(self.Extension).encode(ExternalEncoding), input_name='Extension'), namespace_))
    def hasContent_(self):
        if (
            self.Number is not None or
            self.Extension is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PhoneNumberType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = "%s",\n' % (self.Type,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Number is not None:
            showIndent(outfile, level)
            outfile.write('Number=%s,\n' % quote_python(self.Number).encode(ExternalEncoding))
        if self.Extension is not None:
            showIndent(outfile, level)
            outfile.write('Extension=%s,\n' % quote_python(self.Extension).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        if nodeName_ == 'Number':
            Number_ = child_.text
            self.Number = Number_
            self.validate_Number(self.Number)    # validate type Number
        elif nodeName_ == 'Extension':
            Extension_ = child_.text
            self.Extension = Extension_
            self.validate_Extension(self.Extension)    # validate type Extension
# end class PhoneNumberType


class ResidenceStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MonthsAt=None, YearsAt=None, valueOf_=None):
        self.MonthsAt = _cast(None, MonthsAt)
        self.YearsAt = _cast(None, YearsAt)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ResidenceStatusType.subclass:
            return ResidenceStatusType.subclass(*args_, **kwargs_)
        else:
            return ResidenceStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonthsAt(self): return self.MonthsAt
    def set_MonthsAt(self, MonthsAt): self.MonthsAt = MonthsAt
    def validate_MonthsAtType(self, value):
        # Validate type MonthsAtType, a restriction on xs:string.
        pass
    def get_YearsAt(self): return self.YearsAt
    def set_YearsAt(self, YearsAt): self.YearsAt = YearsAt
    def validate_YearsAtType(self, value):
        # Validate type YearsAtType, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ResidenceStatusType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ResidenceStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResidenceStatusType'):
        outfile.write(' MonthsAt=%s' % (quote_attrib(self.MonthsAt), ))
        outfile.write(' YearsAt=%s' % (quote_attrib(self.YearsAt), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResidenceStatusType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ResidenceStatusType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MonthsAt is not None and 'MonthsAt' not in already_processed:
            already_processed.append('MonthsAt')
            showIndent(outfile, level)
            outfile.write('MonthsAt = "%s",\n' % (self.MonthsAt,))
        if self.YearsAt is not None and 'YearsAt' not in already_processed:
            already_processed.append('YearsAt')
            showIndent(outfile, level)
            outfile.write('YearsAt = "%s",\n' % (self.YearsAt,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('MonthsAt')
        if value is not None and 'MonthsAt' not in already_processed:
            already_processed.append('MonthsAt')
            self.MonthsAt = value
        value = attrs.get('YearsAt')
        if value is not None and 'YearsAt' not in already_processed:
            already_processed.append('YearsAt')
            self.YearsAt = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class ResidenceStatusType


class InsuranceCompanyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, MonthsWith=None, YearsWith=None, valueOf_=None):
        self.MonthsWith = _cast(int, MonthsWith)
        self.YearsWith = _cast(int, YearsWith)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if InsuranceCompanyType.subclass:
            return InsuranceCompanyType.subclass(*args_, **kwargs_)
        else:
            return InsuranceCompanyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MonthsWith(self): return self.MonthsWith
    def set_MonthsWith(self, MonthsWith): self.MonthsWith = MonthsWith
    def get_YearsWith(self): return self.YearsWith
    def set_YearsWith(self, YearsWith): self.YearsWith = YearsWith
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='InsuranceCompanyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='InsuranceCompanyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InsuranceCompanyType'):
        outfile.write(' MonthsWith="%s"' % self.gds_format_integer(self.MonthsWith, input_name='MonthsWith'))
        outfile.write(' YearsWith="%s"' % self.gds_format_integer(self.YearsWith, input_name='YearsWith'))
    def exportChildren(self, outfile, level, namespace_='', name_='InsuranceCompanyType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InsuranceCompanyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.MonthsWith is not None and 'MonthsWith' not in already_processed:
            already_processed.append('MonthsWith')
            showIndent(outfile, level)
            outfile.write('MonthsWith = %d,\n' % (self.MonthsWith,))
        if self.YearsWith is not None and 'YearsWith' not in already_processed:
            already_processed.append('YearsWith')
            showIndent(outfile, level)
            outfile.write('YearsWith = %d,\n' % (self.YearsWith,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('MonthsWith')
        if value is not None and 'MonthsWith' not in already_processed:
            already_processed.append('MonthsWith')
            try:
                self.MonthsWith = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('YearsWith')
        if value is not None and 'YearsWith' not in already_processed:
            already_processed.append('YearsWith')
            try:
                self.YearsWith = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class InsuranceCompanyType


class VehUseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AnnualMiles=None, WeeklyCommuteDays=None, DailyCommuteMiles=None, valueOf_=None):
        self.AnnualMiles = _cast(None, AnnualMiles)
        self.WeeklyCommuteDays = _cast(None, WeeklyCommuteDays)
        self.DailyCommuteMiles = _cast(None, DailyCommuteMiles)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if VehUseType.subclass:
            return VehUseType.subclass(*args_, **kwargs_)
        else:
            return VehUseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AnnualMiles(self): return self.AnnualMiles
    def set_AnnualMiles(self, AnnualMiles): self.AnnualMiles = AnnualMiles
    def validate_AnnualMilesType(self, value):
        # Validate type AnnualMilesType, a restriction on xs:string.
        pass
    def get_WeeklyCommuteDays(self): return self.WeeklyCommuteDays
    def set_WeeklyCommuteDays(self, WeeklyCommuteDays): self.WeeklyCommuteDays = WeeklyCommuteDays
    def validate_WeeklyCommuteDaysType(self, value):
        # Validate type WeeklyCommuteDaysType, a restriction on xs:int.
        pass
    def get_DailyCommuteMiles(self): return self.DailyCommuteMiles
    def set_DailyCommuteMiles(self, DailyCommuteMiles): self.DailyCommuteMiles = DailyCommuteMiles
    def validate_DailyCommuteMilesType(self, value):
        # Validate type DailyCommuteMilesType, a restriction on xs:int.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='VehUseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='VehUseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VehUseType'):
        outfile.write(' AnnualMiles=%s' % (quote_attrib(self.AnnualMiles), ))
        outfile.write(' WeeklyCommuteDays=%s' % (quote_attrib(self.WeeklyCommuteDays), ))
        outfile.write(' DailyCommuteMiles=%s' % (quote_attrib(self.DailyCommuteMiles), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VehUseType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VehUseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.AnnualMiles is not None and 'AnnualMiles' not in already_processed:
            already_processed.append('AnnualMiles')
            showIndent(outfile, level)
            outfile.write('AnnualMiles = "%s",\n' % (self.AnnualMiles,))
        if self.WeeklyCommuteDays is not None and 'WeeklyCommuteDays' not in already_processed:
            already_processed.append('WeeklyCommuteDays')
            showIndent(outfile, level)
            outfile.write('WeeklyCommuteDays = %d,\n' % (self.WeeklyCommuteDays,))
        if self.DailyCommuteMiles is not None and 'DailyCommuteMiles' not in already_processed:
            already_processed.append('DailyCommuteMiles')
            showIndent(outfile, level)
            outfile.write('DailyCommuteMiles = %d,\n' % (self.DailyCommuteMiles,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('AnnualMiles')
        if value is not None and 'AnnualMiles' not in already_processed:
            already_processed.append('AnnualMiles')
            self.AnnualMiles = value
        value = attrs.get('WeeklyCommuteDays')
        if value is not None and 'WeeklyCommuteDays' not in already_processed:
            already_processed.append('WeeklyCommuteDays')
            try:
                self.WeeklyCommuteDays = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('DailyCommuteMiles')
        if value is not None and 'DailyCommuteMiles' not in already_processed:
            already_processed.append('DailyCommuteMiles')
            try:
                self.DailyCommuteMiles = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class VehUseType


class EducationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GoodStudentDiscount=None, valueOf_=None):
        self.GoodStudentDiscount = _cast(None, GoodStudentDiscount)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EducationType.subclass:
            return EducationType.subclass(*args_, **kwargs_)
        else:
            return EducationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GoodStudentDiscount(self): return self.GoodStudentDiscount
    def set_GoodStudentDiscount(self, GoodStudentDiscount): self.GoodStudentDiscount = GoodStudentDiscount
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='EducationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='EducationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EducationType'):
        outfile.write(' GoodStudentDiscount=%s' % (quote_attrib(self.GoodStudentDiscount), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EducationType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EducationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GoodStudentDiscount is not None and 'GoodStudentDiscount' not in already_processed:
            already_processed.append('GoodStudentDiscount')
            showIndent(outfile, level)
            outfile.write('GoodStudentDiscount = "%s",\n' % (self.GoodStudentDiscount,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('GoodStudentDiscount')
        if value is not None and 'GoodStudentDiscount' not in already_processed:
            already_processed.append('GoodStudentDiscount')
            self.GoodStudentDiscount = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class EducationType


class CreditRatingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Bankruptcy=None, valueOf_=None):
        self.Bankruptcy = _cast(None, Bankruptcy)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CreditRatingType.subclass:
            return CreditRatingType.subclass(*args_, **kwargs_)
        else:
            return CreditRatingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Bankruptcy(self): return self.Bankruptcy
    def set_Bankruptcy(self, Bankruptcy): self.Bankruptcy = Bankruptcy
    def validate_YesNo(self, value):
        # Validate type YesNo, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='CreditRatingType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='CreditRatingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRatingType'):
        outfile.write(' Bankruptcy=%s' % (quote_attrib(self.Bankruptcy), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRatingType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CreditRatingType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Bankruptcy is not None and 'Bankruptcy' not in already_processed:
            already_processed.append('Bankruptcy')
            showIndent(outfile, level)
            outfile.write('Bankruptcy = "%s",\n' % (self.Bankruptcy,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Bankruptcy')
        if value is not None and 'Bankruptcy' not in already_processed:
            already_processed.append('Bankruptcy')
            self.Bankruptcy = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class CreditRatingType


class HomeCoverageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PersonalLiability=None, Deductible=None, valueOf_=None):
        self.PersonalLiability = _cast(None, PersonalLiability)
        self.Deductible = _cast(None, Deductible)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HomeCoverageType.subclass:
            return HomeCoverageType.subclass(*args_, **kwargs_)
        else:
            return HomeCoverageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PersonalLiability(self): return self.PersonalLiability
    def set_PersonalLiability(self, PersonalLiability): self.PersonalLiability = PersonalLiability
    def validate_plCoverage(self, value):
        # Validate type plCoverage, a restriction on xs:string.
        pass
    def get_Deductible(self): return self.Deductible
    def set_Deductible(self, Deductible): self.Deductible = Deductible
    def validate_deductibleAmt(self, value):
        # Validate type deductibleAmt, a restriction on xs:string.
        pass
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='HomeCoverageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HomeCoverageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HomeCoverageType'):
        outfile.write(' PersonalLiability=%s' % (quote_attrib(self.PersonalLiability), ))
        outfile.write(' Deductible=%s' % (quote_attrib(self.Deductible), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HomeCoverageType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HomeCoverageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.PersonalLiability is not None and 'PersonalLiability' not in already_processed:
            already_processed.append('PersonalLiability')
            showIndent(outfile, level)
            outfile.write('PersonalLiability = "%s",\n' % (self.PersonalLiability,))
        if self.Deductible is not None and 'Deductible' not in already_processed:
            already_processed.append('Deductible')
            showIndent(outfile, level)
            outfile.write('Deductible = "%s",\n' % (self.Deductible,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('PersonalLiability')
        if value is not None and 'PersonalLiability' not in already_processed:
            already_processed.append('PersonalLiability')
            self.PersonalLiability = value
        value = attrs.get('Deductible')
        if value is not None and 'Deductible' not in already_processed:
            already_processed.append('Deductible')
            self.Deductible = value
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        pass
# end class HomeCoverageType


class HomeLead(HomeLeadType):
    subclass = None
    superclass = HomeLeadType
    def __init__(self, PersonInfo=None, PropertyAddress=None, PropertyProfile=None, PropertyFeatures=None, Claims=None):
        super(HomeLead, self).__init__(PersonInfo, PropertyAddress, PropertyProfile, PropertyFeatures, Claims, )
        pass
    def factory(*args_, **kwargs_):
        if HomeLead.subclass:
            return HomeLead.subclass(*args_, **kwargs_)
        else:
            return HomeLead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='HomeLead', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='HomeLead')
        # outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        # outfile.write(' xsi:type="HomeLead"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HomeLead'):
        super(HomeLead, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HomeLead')
    def exportChildren(self, outfile, level, namespace_='', name_='HomeLead'):
        super(HomeLead, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(HomeLead, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HomeLead'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HomeLead, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HomeLead, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(HomeLead, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        super(HomeLead, self).buildChildren(child_, nodeName_, True)
        pass
# end class HomeLead


class AutoLead(AutoLeadType):
    subclass = None
    superclass = AutoLeadType
    def __init__(self, Vehicles=None, Drivers=None):
        super(AutoLead, self).__init__(Vehicles, Drivers, )
        pass
    def factory(*args_, **kwargs_):
        if AutoLead.subclass:
            return AutoLead.subclass(*args_, **kwargs_)
        else:
            return AutoLead(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='AutoLead', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='AutoLead')
        # outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        # outfile.write(' xsi:type="AutoLead"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutoLead'):
        super(AutoLead, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutoLead')
    def exportChildren(self, outfile, level, namespace_='', name_='AutoLead'):
        super(AutoLead, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(AutoLead, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AutoLead'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AutoLead, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutoLead, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(AutoLead, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        super(AutoLead, self).buildChildren(child_, nodeName_, True)
        pass
# end class AutoLead


class InsurancePolicy(InsurancePolicyType):
    subclass = None
    superclass = InsurancePolicyType
    def __init__(self, NewPolicy=None, PriorPolicy=None):
        super(InsurancePolicy, self).__init__(NewPolicy, PriorPolicy, )
        pass
    def factory(*args_, **kwargs_):
        if InsurancePolicy.subclass:
            return InsurancePolicy.subclass(*args_, **kwargs_)
        else:
            return InsurancePolicy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='InsurancePolicy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='InsurancePolicy')
        # outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        # outfile.write(' xsi:type="InsurancePolicy"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InsurancePolicy'):
        super(InsurancePolicy, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InsurancePolicy')
    def exportChildren(self, outfile, level, namespace_='', name_='InsurancePolicy'):
        super(InsurancePolicy, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(InsurancePolicy, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='InsurancePolicy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InsurancePolicy, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InsurancePolicy, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(InsurancePolicy, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        super(InsurancePolicy, self).buildChildren(child_, nodeName_, True)
        pass
# end class InsurancePolicy


class ContactDetails(ContactDetailsType):
    subclass = None
    superclass = ContactDetailsType
    def __init__(self, FirstName=None, LastName=None, StreetAddress=None, City=None, State=None, ZIPCode=None, Email=None, PhoneNumbers=None, ResidenceStatus=None):
        super(ContactDetails, self).__init__(FirstName, LastName, StreetAddress, City, State, ZIPCode, Email, PhoneNumbers, ResidenceStatus, )
        pass
    def factory(*args_, **kwargs_):
        if ContactDetails.subclass:
            return ContactDetails.subclass(*args_, **kwargs_)
        else:
            return ContactDetails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='ContactDetails', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='ContactDetails')
        # outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        # outfile.write(' xsi:type="ContactDetails"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContactDetails'):
        super(ContactDetails, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContactDetails')
    def exportChildren(self, outfile, level, namespace_='', name_='ContactDetails'):
        super(ContactDetails, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(ContactDetails, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ContactDetails'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ContactDetails, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContactDetails, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ContactDetails, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        super(ContactDetails, self).buildChildren(child_, nodeName_, True)
        pass
# end class ContactDetails


class PartnerExcludeDirective(PartnerExcludeDirectiveType):
    subclass = None
    superclass = PartnerExcludeDirectiveType
    def __init__(self, PartnerExclude=None):
        super(PartnerExcludeDirective, self).__init__(PartnerExclude, )
        pass
    def factory(*args_, **kwargs_):
        if PartnerExcludeDirective.subclass:
            return PartnerExcludeDirective.subclass(*args_, **kwargs_)
        else:
            return PartnerExcludeDirective(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='', name_='PartnerExcludeDirective', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='PartnerExcludeDirective')
        # outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        # outfile.write(' xsi:type="PartnerExcludeDirective"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PartnerExcludeDirective'):
        super(PartnerExcludeDirective, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PartnerExcludeDirective')
    def exportChildren(self, outfile, level, namespace_='', name_='PartnerExcludeDirective'):
        super(PartnerExcludeDirective, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(PartnerExcludeDirective, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PartnerExcludeDirective'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PartnerExcludeDirective, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PartnerExcludeDirective, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(PartnerExcludeDirective, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, nodeName_, from_subclass=False):
        super(PartnerExcludeDirective, self).buildChildren(child_, nodeName_, True)
        pass
# end class PartnerExcludeDirective


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MSALead'
        rootClass = MSALead
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MSALead'
        rootClass = MSALead
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="MSALead",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'MSALead'
        rootClass = MSALead
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from msa import *\n\n')
    sys.stdout.write('import msa as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Accident",
    "Accidents",
    "AutoLead",
    "AutoLeadType",
    "Claim",
    "Claims",
    "ConstructionDetails",
    "ContactDetails",
    "ContactDetailsType",
    "CreditRatingType",
    "DUI",
    "DUIs",
    "Driver",
    "Drivers",
    "DriversLicense",
    "DrivingRecord",
    "EducationType",
    "HomeCoverageType",
    "HomeLead",
    "HomeLeadType",
    "InsuranceCompanyType",
    "InsurancePolicy",
    "InsurancePolicyType",
    "LeadData",
    "MSALead",
    "NewPolicy",
    "PartnerExcludeDirective",
    "PartnerExcludeDirectiveType",
    "PersonInfo",
    "PersonalInfo",
    "PhoneNumberType",
    "PhoneNumbers",
    "PriorPolicy",
    "PropertyAddress",
    "PropertyFeatures",
    "PropertyProfile",
    "ResidenceStatusType",
    "Ticket",
    "Tickets",
    "VehUseType",
    "Vehicle",
    "VehicleData",
    "Vehicles"
    ]
